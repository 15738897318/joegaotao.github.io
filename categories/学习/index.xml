<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>学习 on Tao Gao | 高涛</title>
    <link>/categories/%E5%AD%A6%E4%B9%A0/</link>
    <description>Recent content in 学习 on Tao Gao | 高涛</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>高涛 版权所有 2013 - 2017</copyright>
    <lastBuildDate>Mon, 28 Aug 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="/categories/%E5%AD%A6%E4%B9%A0/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>相关、抽样、融合</title>
      <link>/2017/08/28/%E7%9B%B8%E5%85%B3%E6%8A%BD%E6%A0%B7%E8%9E%8D%E5%90%88/</link>
      <pubDate>Mon, 28 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/08/28/%E7%9B%B8%E5%85%B3%E6%8A%BD%E6%A0%B7%E8%9E%8D%E5%90%88/</guid>
      <description>
        

&lt;p&gt;各个实用的系统工程框架，对于处理一个复杂的目标问题，多半是模块化分级联动的，这类处理方式，在思想上都可以认为有种模型融合（Ensemble）味道。比如实操中，我们多会大任务化解为小任务，难目标分解为多个较为易解的目标，最终的问题则成为了多小问题后的组合和综合。相比一上来想要用一套模型来解决，这种处理方式也更加接近实际工作方式。因为任务一旦较好的拆解，就可以分配给多个人来并行处理，相比集中式的在某个模型上解决一个难问题可能有效得多。&lt;/p&gt;

&lt;p&gt;所以换个角度来看统计学，深度学习中框架性的设计我觉得是传统统计最应该学习的地方，好的框架不仅仅对于解决问题非常有帮助，并且也好理解好调试。虽然一个问题被分级分块处理，可能没法做到深度学习用一个后向传播算法来统一调整，也不如单模型简洁优美，但是实际用起来更好用，更能有效解决问题。所以在软件工程上，有系统架构师掌舵，在数据建模上，应该也有数据模型架构师掌舵，设计的框架耦合性不高，在框架的每个角落，你都可以尽情尝试和打磨各类方法，进而推动整个结果的进化。下面我们就来谈谈关于模型融合的一些有用的东西。&lt;/p&gt;

&lt;h3 id=&#34;1-一个重要而实用的定理&#34;&gt;1. 一个重要而实用的定理&lt;/h3&gt;

&lt;p&gt;对于模型融合（Ensemble）思想，抽样和相关性处在比较重要的理论和实践地位，并且两者紧密结合。相关性和抽样对于模型融合的影响，可以用经典的偏误差分解方法来探究，这样可以让我们更深刻的理解每块设计所带来的影响，进而在自己设计整个ensemble框架时，知道哪些是更重要值得花精力的点，哪些相对次要。&lt;/p&gt;

&lt;p&gt;在&lt;a href=&#34;https://cosx.org/2015/08/some-basic-ideas-and-methods-of-model-selection&#34;&gt;关于模型选择的讨论&lt;/a&gt;中，我们知道对于平方损失，某个点的预测误差，可以分解为如下三部分&lt;/p&gt;

&lt;p&gt;$$
\begin{split}
\text{Err}(x_0) &amp;amp; =  \mathbb{E}(L(y_0, \hat{f}(x_0))| X = x_0) \&lt;br /&gt;
&amp;amp; =  \underbrace{\sigma^2_{\epsilon}}_{IrreducibleError} + \underbrace{(f(x_0) - \mathbb{E}\hat{f}(x_0)) ^ 2}_{ModelBias^2} + \underbrace{\mathbb{E}(\hat{f}(x_0) - \mathbb{E}\hat{f}(x_0))^2}_{ModelVariance}
\end{split}
$$&lt;/p&gt;

&lt;p&gt;对于基于样本和特征抽样随机模型，也可推导出如上的分解式子，令*δ*表示控制模型随机性的参数（随机性可以体现在对样本的随机抽取上，也可以体现在对于特征的随机抽取上），𝒯为训练集，那么融合起来一系列随机模型的平均值$\Psi_{\mathcal{T}, \delta_{1,..m}}(\mathbf{x}) = \frac{1}{M}\sum^M_{m=1} \hat{f}_{\mathcal{T}, \delta_m}(\mathbf{x})$的期望平均损失为&lt;/p&gt;

&lt;p&gt;𝔼&lt;sub&gt;𝒯&lt;/sub&gt;(Err(&lt;em&gt;Ψ&lt;/em&gt;&lt;sub&gt;𝒯, &lt;em&gt;δ&lt;/em&gt;&lt;sub&gt;1, ..&lt;em&gt;m&lt;/em&gt;&lt;/sub&gt;&lt;/sub&gt;(&lt;strong&gt;x&lt;/strong&gt;)))=noise(&lt;strong&gt;x&lt;/strong&gt;)+bias&lt;sup&gt;2&lt;/sup&gt;(&lt;strong&gt;x&lt;/strong&gt;)+variance(&lt;strong&gt;x&lt;/strong&gt;)
 其中&lt;/p&gt;

&lt;p&gt;$$
\left\{
\begin{array}{l}
\text{noise}(\mathbf{x}) = \sigma^2_{\epsilon}\&lt;br /&gt;
\text{bias}^2(\mathbf{x}) =  (f(\mathbf{x}) - u_{\mathcal{T}, \delta}(\mathbf{x}))^2, \,\,\, u_{\mathcal{L}, \delta}(\mathbf{x}) = \mathbb{E}_{\mathcal{T},\delta}(\hat{f}_{\mathcal{T}, \delta}(\mathbf{x}))\&lt;br /&gt;
\text{variance}(\mathbf{x}) = \rho(\mathbf{x}) \sigma^2_{\mathcal{T}, \delta}(\mathbf{x}) + \frac{1 - \rho(\mathbf{x})}{M} \sigma^2_{\mathcal{T}, \delta}(\mathbf{x}), \,\,\, \sigma^2_{\mathcal{T}, \delta}(\mathbf{x})=\mathbb{Var}_{\mathcal{T},\delta}(\hat{f}_{\mathcal{T},\delta}(\mathbf{x}))
\end{array}
\right.
$$&lt;/p&gt;

&lt;p&gt;而&lt;em&gt;ρ&lt;/em&gt;(&lt;strong&gt;x&lt;/strong&gt;)则是来源同一样本集的两个不同随机模型的预测值的皮尔逊相关系数。从上述这个式子，有如下几个结论：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;偏倚（bias）：集成模型与单个随机模型是一样的；&lt;/li&gt;
&lt;li&gt;方差（variance）：随着随机模型个数增加，variance(&lt;strong&gt;x&lt;/strong&gt;)→&lt;em&gt;ρ&lt;/em&gt;(&lt;strong&gt;x&lt;/strong&gt;)&lt;em&gt;σ&lt;/em&gt;&lt;sub&gt;ℒ, &lt;em&gt;δ&lt;/em&gt;&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt;(&lt;strong&gt;x&lt;/strong&gt;),

&lt;ul&gt;
&lt;li&gt;当随机模型间的相关性非常高时，即随机效应比较弱时，则集成模型的方差和单个随机模型的方差接近，&lt;/li&gt;
&lt;li&gt;当随机模型件的相关性非常弱时，即随机效应比较强时，则集成模型的方差则趋近于0，&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从上面我们可以看到做模型融合时，&lt;strong&gt;模型的相关性对于降低预测损失非常重要&lt;/strong&gt;，在较好的控制随机模型带来的偏误情况下，降低随机模型的相关性可以大幅提升模型预测准确性。那么这种模型相关性是什么带来的呢？Geurts
(2002) 有这样一个关于模型融合的方差结论&lt;/p&gt;

&lt;p&gt;$$
\text{variance}(\mathbf{x})  = \mathbb{Var}_{\mathcal{T}}(\mathbb{E}_{\delta|\mathcal{T}}(f_{\mathcal{T},\delta}(\mathbf{x}))) + \frac{1}{M}\mathbb{E}_{\mathcal{T}}(\mathbb{Var}_{\delta|\mathbb{T}}(f_{\mathcal{T}, \delta}(\mathbf{x})))
$$
 与上述分解结合下，即可得到如下式子&lt;/p&gt;

&lt;p&gt;$$
\rho(\mathbf{x}) = \frac{\mathbb{Var}_{\mathcal{T}}(\mathbb{E}_{\delta | \mathcal{T}}(f_{\mathcal{T},\delta}(\mathbf{x})))}{\mathbb{Var}_{\mathcal{T}}(\mathbb{E}_{\delta|\mathcal{T}}(f_{\mathcal{T},\delta}(\mathbf{x}))) + \mathbb{E}_{\mathcal{T}}(\mathbb{Var}_{\delta|\mathbb{T}}(f_{\mathcal{T}, \delta}(\mathbf{x})))}
$$&lt;/p&gt;

&lt;p&gt;从该式可以看到，随机模型间的相关系数实际上是由于训练集𝒯所引起的方差与总方差间的比值。如果构件模型的方差主要来源于整体训练集时，那么随机模型就会长得挺像，相关性比较高，这种情况通常是训练样本量非常充足，涵盖的信息量很全，或者是训练样本冗余度很高，两两间相关性很高，随机性起的作用很小；而如果构建模型的方差主要来源于随机机制而非训练集自身的信息时，则模型间的相关性很低，这种情况，原因可能有很多，比如训练集样本量不大、模型族的稳定性不高，随机机制使得模型构建差异较大等等。总而言之，样本量、样本间的相关性、特征间的相关性、随机机制是随机模型相关性的根源。&lt;/p&gt;

&lt;p&gt;将上述结论总结道一个更为有用的实际经验便是（来源于Louppe（2015）研究随机森林）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数据量较大时候，对每个估计量使用所有数据通常提升有限，而合适大小的随机样本并不会引起精度的显著下降，因为很多都是冗余样本；而此时子抽样带来的好处是训练时长和内存消耗会显著减少，可规模化能力更强；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据较为充分时对于特征的抽样对于提高精度更为关键，样本的抽样通常效果并不明显&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个也很符合直觉和实际情况，如果数据量比较充足，你换换样本，很可能多次换到的样本子集比较相似，对于最终模型预测结果大家则都会比较像）；但是如果特征间相关性比较低，你换换特征，那么模型预测的结果可能就是千差万别了。&lt;/p&gt;

&lt;p&gt;当然还有其他更为极端的方式，可以让模型在估计时候都无需样本集来帮助估计，直接全部随机掉，比如&lt;a href=&#34;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.65.7485&amp;amp;rep=rep1&amp;amp;type=pdf&#34;&gt;Extremely
Randomized
Trees(ExtraTrees)&lt;/a&gt;让树的节点划分也无需通过纯度或者精度等标准来优化，直接在特征的最小值和最大值之间随机取个数即可。这种处理方式，使得模型估计脱离了训练样本，那么预测方差就完全来源于随机机制，随机模型间的相关性自然就低了。&lt;/p&gt;

&lt;p&gt;总而言之，误差分解表明，对于模型融合，我们要选择相对比较低偏误的基础模型，然后根据对样本、特征的理解，设计抽样机制得到随机模型，通过模型融合来降低预测方差，进而整体降低平均预测误差。随机森林的框架就是一个很好的模板，如果要结合深度学习这种级联框架，那么则需要大量实践才能够逐步对各个模型特性以及抽样机制有比较好的理解和控制。&lt;/p&gt;

&lt;p&gt;当然上述说的很细节，用更宽泛大家都可能记得住的语言来说，模型融合一般会比较有效的三个直观性原因（Dietterich，2000b）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;统计性：Box说过“所有模型都是错的，但是有些是有用的”，多个不相关模型的预测，会降低模型假设错误的风险；&lt;/li&gt;
&lt;li&gt;计算性：模型不少为了好解，都做了些假设简化处理，这种简化虽说可能是全局最优，但实际得到的仍可能是局部最优，而多个模型融合，好比提供了多个不同起始点来求解，相对于单模型对于未知的真模型可能是更好的逼近；&lt;/li&gt;
&lt;li&gt;表示性：对于有限集，真模型几乎不可能被任何一个候选模型恰好表示，而模型融合，
拓展了表示函数的空间，可能更好的表示真模型。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-对实际业务操作的启发&#34;&gt;2. 对实际业务操作的启发&lt;/h3&gt;

&lt;p&gt;在实际预测业务中，我们通常会发现业务经验往往比模型重要得多，比如很多时候会根据业务经验对样本或者变量进行某些分组，分别训练后再融合，经过这些这样处理后的效果通常会比没有业务经验的人直接套模型会好得多，造成的这种结果的原因是什么呢？&lt;/p&gt;

&lt;p&gt;经过上述对模型融合的讨论，可认为是抽样带来的功劳。有人可能会感到疑惑，这怎么算到抽样头上去了呢？实际上抽样的发生也是按照概率来抽，如果没有任何先验知识，等概率随机抽样通常来说是更好的方式，如果有某些先验知识，那么非等概率的重要性抽样相比等概率抽样会更有效率，模型效果也会有显著提升。那么，如何获得这种重要性呢？这就是比较艺术或者比较tricky的地方，没有业务背景的建模同学，可以根据业务需求做各种样本和特征的相关性分析，而有业务背景不会建模的同学，他们对于信息重要程度和相关性的直觉和经验之上（脑补建模），所以有经验的从业人员的业务经验对实际建模其实都比较宝贵，可以帮助规避很多弯路。借助各种形式的抽样，每一步我们都可能获取更加稳定的预测。&lt;/p&gt;

&lt;p&gt;实际业务的框架构建非常不容易，从数据获取、处理，到一级级的子问题分解和提取，都不是一个容易的过程，要想得到比较好的结果，不妨多从随机森林的角度去设计业务框架，这样是很符合“人人都有活干，人人都有贡献，人人都在推动集体的前进”的社会主义价值观的：）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b10000_10000&amp;amp;sec=1504017575&amp;amp;di=f4542baacf09f2a888a9b666f2101c68&amp;amp;src=http://pic1.997788.com/mini/shopstation/pic/MP/00/0000/000046/MP00004677.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

        
      </description>
    </item>
    
    <item>
      <title>分布式计算、统计学习与ADMM算法</title>
      <link>/2014/02/11/admm-stat-compute/</link>
      <pubDate>Tue, 11 Feb 2014 00:00:00 +0000</pubDate>
      
      <guid>/2014/02/11/admm-stat-compute/</guid>
      <description>
        

&lt;p&gt;在整理旧电脑时，才发现13年下半年电脑里有不少残文。老师说，东西搁下了再拿起来花费的时间和之前可能差不多。我一眼看过去这篇关于分布式计算的文章，貌似还真的没有了当时理解的深度和感觉。当时还想利用ADMM算法，把统计中常见的带惩罚的高维问题在此框架下用R重写一下，但是中途多种事情一耽搁，就早已抛之脑后。看来任何事情，真的还是需要坚持，哪怕拨点时间都是好的。先把一篇残文扔出来祭奠下过去的13年吧。公式多文字长，慎入！&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;业界一直在谈论大数据，对于统计而言，大数据其实意味着要不是样本量增加*n* → ∞，要不就是维度的增加*p* → ∞，亦或者两者同时增加，并且维度与样本量的增长速度呈线性或者指数型增长。在稀疏性的假设条件下，再加上一些正则性方法，统计学家可以证明各种加penalty的模型所给出的参数估计具有良好的统计性质，收敛速度也有保证，同时还会给出一些比较好的迭代算法，但是，他们并没有考虑真实环境下的所消耗的计算时间。虽然统计学家也希望尽量寻求迭代数目比较少的算法（比如one-step估计），但是面对真实的Gb级别以上的数据，很多时候我们还是无法直接用这些算法，原因是一般的硬件都无法支撑直接对所有数据进行运算的要求。如果想减少抽样误差，不想抽样，又想提高估计的精度，那么还是需要寻求其他思路，结合已有的模型思想来解决这些问题。在目前条件下，并行化、分布式计算是一种比较好的解决思路，利用多核和多机器的优势，这些好算法便可以大规模应用，处理大数据优势便体现出来了。对于统计而言，数据量越大当然信息越可能充分（假设冗余成分不是特别多），因为大样本性质本身就希望样本越多越好嘛。&lt;/p&gt;

&lt;p&gt;本文是基于Stephen Boyd 2011年的文章《Distributed Optimization and
Statistical Learning via the Alternating Direction Method of
Multipliers》进行的翻译和总结。Boyd也给出了利用matlab的CVX包实现的多种优化问题的&lt;a href=&#34;http://www.stanford.edu/~boyd/papers/admm_distr_stats.html&#34;&gt;matlab示例&lt;/a&gt;。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;ol&gt;
&lt;li&gt;优化的一些基本算法思想
&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ADMM算法并不是一个很新的算法，他只是整合许多不少经典优化思路，然后结合现代统计学习所遇到的问题，提出了一个比较一般的比较好实施的分布式计算框架。因此必须先要了解一些基本算法思想。&lt;/p&gt;

&lt;h3 id=&#34;1-1-dual-ascent&#34;&gt;1.1 Dual Ascent&lt;/h3&gt;

&lt;p&gt;对于凸函数的优化问题，对偶上升法核心思想就是引入一个对偶变量，然后利用交替优化的思路，使得两者同时达到optimal。一个凸函数的对偶函数其实就是原凸函数的一个下界，因此可以证明一个较好的性质：在强对偶性假设下，即最小化原凸函数（primal）等价于最大化对偶函数（dual），两者会同时达到optimal。这种转化可以将原来很多的参数约束条件变得少了很多，以利于做优化。具体表述如下：&lt;/p&gt;

&lt;p&gt;$$
\begin{array}{lc}
\min &amp;amp; f(x)\&lt;br /&gt;
s.t. &amp;amp; Ax = b \&lt;br /&gt;
\end{array}
\Longrightarrow L(x, y) = f(x) + y^T(Ax - b) \overset{对偶函数（下界）}{\Longrightarrow} g(y) = \inf_x L(x, y)
$$&lt;/p&gt;

&lt;p&gt;在强对偶性的假设下，primal和dual问题同时达到最优。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;x&lt;/em&gt;&lt;sup&gt;⋆&lt;/sup&gt; = argmin&lt;sub&gt;&lt;em&gt;x&lt;/em&gt;&lt;/sub&gt;&lt;em&gt;L&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;, &lt;em&gt;y&lt;/em&gt;&lt;sup&gt;⋆&lt;/sup&gt;)&lt;/p&gt;

&lt;p&gt;因此，若对偶函数&lt;em&gt;g&lt;/em&gt;(&lt;em&gt;y&lt;/em&gt;)可导，便可以利用梯度上升法，交替更新参数，使得同时收敛到最优。迭代如下：&lt;/p&gt;

&lt;p&gt;$$
\begin{split}
x^{k + 1} : &amp;amp; =\arg\min_x L(x, y^k) \quad \text{($x$-最小化步)} \&lt;br /&gt;
y^{k + 1} : &amp;amp; = y^k + \alpha^k \nabla g(y) = y^k + \alpha^k (Ax^{k + 1} - b)  \quad \text{(对偶变量更新，$\alpha^k$是步长)} \&lt;br /&gt;
\end{split}
$$&lt;/p&gt;

&lt;p&gt;当*g*不可微的时候也可以将其转化下，成为一个所谓的subgradient的方法，虽然看起来不错，简单证明下即可知道&lt;em&gt;x&lt;/em&gt;&lt;sup&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sup&gt;和&lt;em&gt;y&lt;/em&gt;&lt;sup&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sup&gt;同时可达到optimal，但是上述条件要求很苛刻：&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)要求严格凸，并且要求*α*选择有比较合适。一般应用中都不会满足（比如&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)是一个非零的&lt;strong&gt;仿射函数&lt;/strong&gt;），因此dual
ascent不会直接应用。&lt;/p&gt;

&lt;h3 id=&#34;1-2-dual-decomposition&#34;&gt;1.2 Dual Decomposition&lt;/h3&gt;

&lt;p&gt;虽然dual
ascent方法有缺陷，要求有些严格，但是他有一个非常好的性质，当目标函数*f*是可分的（&lt;strong&gt;separable&lt;/strong&gt;）时候（参数抑或feature可分），整个问题可以拆解成多个子参数问题，分块优化后汇集起来整体更新。这样非常有利于并行化处理。形式化阐述如下：&lt;/p&gt;

&lt;p&gt;$$
\begin{array}{lc}
\min &amp;amp; f(x) = \sum^N_{i = 1} f_i(x_i), x_i \in \mathbf{R}^{n_i}, x \in \mathbf{R}^n \&lt;br /&gt;
s.t. &amp;amp; Ax = \sum^N_{i = 1} A_i x_i = b, \quad \text{(对$A$矩阵按列切分开)} \&lt;br /&gt;
\end{array}
\Longrightarrow L(x, y) = \sum^N_{i = 1}L_i(x_i, y) = \sum^N_{i = 1}(f_i(x_i) + y^TA_ix_i - \frac{1}{N}y^Tb)
$$&lt;/p&gt;

&lt;p&gt;因此可以看到其实下面在迭代优化时，&lt;em&gt;x&lt;/em&gt;-minimization步即可以拆分为多个子问题的并行优化，对偶变量更新不变这对于feature特别多时还是很有用的。&lt;/p&gt;

&lt;p&gt;$$
\begin{split}
x_i^{k + 1} : &amp;amp; =\arg\min_x L_i(x_i, y^k) \quad \text{(多个$x_i$并行最小化步)} \&lt;br /&gt;
y^{k + 1} : &amp;amp; = y^k + \alpha^k \nabla g(y) = y^k + \alpha^k (Ax^{k + 1} - b) \quad \text{(汇集整体的$x$，然后对偶变量更新)} \&lt;br /&gt;
\end{split}
$$&lt;/p&gt;

&lt;p&gt;对偶分解是非常经典的优化方法，可追溯到1960年代。但是这种想法对后面的分布式优化方法影响较大，比如近期的graph-structure优化问题。&lt;/p&gt;

&lt;h3 id=&#34;1-3-augmented-lagrangians-and-the-method-of-multipliers&#34;&gt;1.3 Augmented Lagrangians and the Method of Multipliers&lt;/h3&gt;

&lt;p&gt;从上面可以看到dual
ascent方法对于目标函数要求比较苛刻，为了放松假设条件，同时比较好优化，于是就有了Augmented
Lagrangians方法，目的就是放松对于&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)严格凸的假设和其他一些条件，同时还能使得算法更加稳健。&lt;/p&gt;

&lt;p&gt;$$
L_{\rho}(x, y) = f(x) + y^T(Ax - b) + \frac{\rho}{2}\|Ax - b\|^2_2
\Longrightarrow
\begin{array}{lc}
\min &amp;amp; f(x) + \frac{\rho}{2}\|Ax - b\|^2_2 \&lt;br /&gt;
s.t. &amp;amp; Ax = b \&lt;br /&gt;
\end{array}
$$&lt;/p&gt;

&lt;p&gt;从上面可以看到该问题等价于最初的问题，因为只要是可行解对目标函数就没有影响。但是加了后面的
(&lt;em&gt;ρ&lt;/em&gt;/2)∥*A**x* − *b*∥&lt;sub&gt;2&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt;
惩罚项的好处是使得对偶函数
&lt;em&gt;g&lt;/em&gt;&lt;sub&gt;&lt;em&gt;ρ&lt;/em&gt;&lt;/sub&gt;(&lt;em&gt;y&lt;/em&gt;)=inf&lt;sub&gt;&lt;em&gt;x&lt;/em&gt;&lt;/sub&gt;&lt;em&gt;L&lt;/em&gt;&lt;sub&gt;&lt;em&gt;ρ&lt;/em&gt;&lt;/sub&gt;(&lt;em&gt;x&lt;/em&gt;, &lt;em&gt;y&lt;/em&gt;)
在更一般的条件下可导。计算过程与之前的dual
ascent基本一样，除了最小化*x*时候加了扩增项。&lt;/p&gt;

&lt;p&gt;$$
\begin{split}
x^{k+1} &amp;amp; = \arg\min_x L_{\rho}(x, y^k) \&lt;br /&gt;
y^{k+1} &amp;amp; = y^k + \rho(Ax^{k+1} - b) \&lt;br /&gt;
\end{split}
$$&lt;/p&gt;

&lt;p&gt;上述也称作method of
multipliers，可能也是因为更新对偶变量*y*时步长由原来变化的&lt;em&gt;α&lt;/em&gt;&lt;sup&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sup&gt;转为固定的*ρ*了吧。该算法在即使&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)不是严格凸或者取值为+∞情况都可以成立，适用面更广。同样可以简单证明primal变量*x*和对偶变量*y*可以同时达到最优。&lt;/p&gt;

&lt;p&gt;虽然Augmented Lagrangians方法有优势，但也破坏了dual
ascent方法的利用分解参数来并行的优势。当*f*是separable时，对于Augmented
Lagrangians却是not
separable的（因为平方项写成矩阵形式无法用之前那种分块形式），因此在*x* − min步时候无法并行优化多个参数&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;。如何改进，继续下面的议题就可以慢慢发现改进思想的来源。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Alternating Direction Method of Multipliers(ADMM)
&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2-1-admm算法概述&#34;&gt;2.1 ADMM算法概述&lt;/h3&gt;

&lt;p&gt;为了整合dual ascent可分解性与method
multiplers优秀的收敛性质，人们就又提出了改进形式的优化ADMM。目的就是想能分解原函数和扩增函数，以便于在对*f*更一般的假设条件下并行优化。ADMM从名字可以看到是在原来Method
of Multipliers加了个Alternating
Direction，可以大概猜想到应该是又想引入新变量，然后交叉换方向来交替优化。形式如下：&lt;/p&gt;

&lt;p&gt;$$
\begin{array}{lc}
\min &amp;amp; f(x) + g(z)\&lt;br /&gt;
s.t. &amp;amp; Ax + Bz = c \&lt;br /&gt;
\end{array}
\Longrightarrow L_{\rho}(x, z, y) = f(x) + g(z) + y^T(Ax + Bz - c) + (\rho/2)\|Ax + Bz - c\|^2_2
$$&lt;/p&gt;

&lt;p&gt;从上面形式确实可以看出，他的思想确实就是想把primal变量、目标函数拆分，但是不再像dual
ascent方法那样，将拆分开的&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;都看做是*x*的一部分，后面融合的时候还需要融合在一起，而是最先开始就将拆开的变量分别看做是不同的变量*x*和*z*，同时约束条件也如此处理，这样的好处就是后面不需要一起融合*x*和*z*，保证了前面优化过程的可分解性。于是ADMM的优化就变成了如下序贯型迭代（这正是被称作alternating
direction的缘故）：&lt;/p&gt;

&lt;p&gt;$$
\begin{split}
x^{k+1} &amp;amp; = \arg\min_x L_{\rho}(x, z^k, y^k) \&lt;br /&gt;
z^{k+1} &amp;amp; = \arg\min_z L_{\rho}(x^{k+1}, z, y^k) \&lt;br /&gt;
y^{k+1} &amp;amp; = y^k + \rho(Ax^{k+1} + Bz^{k+1}- c) \&lt;br /&gt;
\end{split}
$$&lt;/p&gt;

&lt;p&gt;后面我们可以看到这种拆分思想非常适合统计学习中的ℓ&lt;sub&gt;1&lt;/sub&gt;-norm等问题：loss
+
regulazition（注意：一定要保证*z*分解出来，ADMM借助的就是用一个*z*变量来简化问题，不管他是约束还是其他形式也罢，需要构造一个*z*出来，后面具体到细节问题我们会有更深的体会）。&lt;/p&gt;

&lt;p&gt;为了简化形式，ADMM有一个scaled
form形式，其实就是对对偶变量做了scaled处理。先定义每一步更新的残差为*r* = *A&lt;strong&gt;x* + *B&lt;/strong&gt;z* − *c*，于是稍加计算&lt;/p&gt;

&lt;p&gt;$$
\begin{split}
y^T(Ax + Bz - c) + (\rho/2)\|Ax + Bz - c\|^2_2 &amp;amp;=  y^Tr + (\rho/2)\|r\|^2_2 \&lt;br /&gt;
&amp;amp; = (\rho/2)\|r + (1/\rho)y\|^2_2 - (&lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;\rho)\|y\|^2_2 \\
&amp;amp; = (\rho/2)\|r + u\|^2_2 - (\rho/2)\|u\|^2_2 \&lt;br /&gt;
\end{split}
$$&lt;/p&gt;

&lt;p&gt;此处*u* = (1/&lt;em&gt;ρ&lt;/em&gt;)*y*称为scaled dual
variable，并令每一步迭代的残差为&lt;em&gt;r&lt;/em&gt;&lt;sup&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sup&gt; = *A&lt;strong&gt;x*&lt;sup&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sup&gt; + *B&lt;/strong&gt;z*&lt;sup&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sup&gt; − *c*，以及累计残差$u^k = u^0 + \sum^k_{j=1}r^j$，于是ADMM形式就可以简化为如下形式&lt;/p&gt;

&lt;p&gt;$$
\begin{split}
x^{k+1} &amp;amp; = \arg\min_x L_{\rho}(x, z^k, y^k) = \arg\min(f(x)+(\rho/2)\|Ax + Bz^k - c + u^k\|^2_2)\&lt;br /&gt;
z^{k+1} &amp;amp; = \arg\min_z L_{\rho}(x^{k+1}, z, y^k) = \arg\min(g(z) + (\rho/2)\|Ax^{k+1} + Bz - c + u^k\|)\&lt;br /&gt;
u^{k+1} &amp;amp; = u^k + Ax^{k+1} + Bz^{k+1}- c \&lt;br /&gt;
\end{split}
$$&lt;/p&gt;

&lt;p&gt;写成这种形式有利于后面简化优化问题，当然可以不作任何处理。&lt;/p&gt;

&lt;h3 id=&#34;2-2-admm算法性质和评价&#34;&gt;2.2 ADMM算法性质和评价&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;（1）收敛性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;关于收敛性，需要有两个假设条件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;*f*和*g*分别是扩展的实数函数&lt;strong&gt;R&lt;/strong&gt;&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt;(&lt;strong&gt;R&lt;/strong&gt;&lt;sup&gt;&lt;em&gt;m&lt;/em&gt;&lt;/sup&gt;)→&lt;strong&gt;R&lt;/strong&gt;⋃{ + ∞}，且是closed、proper和convex的；&lt;/li&gt;
&lt;li&gt;扩增的lagrangian函数&lt;em&gt;L&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt;有一个鞍点（saddle
point）；对于约束中的矩阵&lt;em&gt;A&lt;/em&gt;, *B*都不需要满秩。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在此两个假设下，可以保证残差、目标函数、对偶变量的收敛性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;：实际应用而言，ADMM收敛速度是很慢的，类似于共轭梯度方法。迭代数十次后只可以得到一个acceptable的结果，与快速的高精度算法（Newton法，内点法等）相比收敛就慢很多了。因此实际应用的时候，其实会将ADMM与其他高精度算法结合起来，这样从一个acceptable的结果变得在预期时间内可以达到较高收敛精度。不过一般在大规模应用问题中，高精度的参数解对于预测效果没有很大的提高，因此实际应用中，短时间内一个acceptable的结果基本就可以直接应用预测了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）停止准则&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于ADMM的能到到optimal的条件此处就不做赘述了，与基本的primal和dual
feasibility 的条件差不多，即各primal
variable的偏导和约束条件为0，从最优条件中可以得到所谓的对偶残差（dual
residuals）和初始残差（primal residuals）形式：&lt;/p&gt;

&lt;p&gt;$$
\begin{split}
s^{k + 1} &amp;amp; = \rho A^TB(z^{k+1} - z^k) \quad (dual \,\, residuals) \&lt;br /&gt;
r^{k + 1} &amp;amp; = Ax^{k+1} + Bz^{k+1} - c \quad (primal \,\, residuals) \&lt;br /&gt;
\end{split}
$$&lt;/p&gt;

&lt;p&gt;相对而言，此处更难把握的其实是停止准则，因为收敛速度问题，要想获得一个还过得去可以拿来用的参数解，那么判断迭代停止还是比较重要的。实际应用中，一般都根据primal
residuals和dual
residuals足够小来停止迭代，阈值包含了绝对容忍度（absolute
tolerance）和相对容忍度（relative
tolerance），设置还是非常灵活和难把握的（貌似网上有不少人吐槽这个停止准则的不靠谱-
-！），具体形式如下：&lt;/p&gt;

&lt;p&gt;$$
\begin{split}
\|s^k\|_2 \leq \epsilon^{\text{dual}} &amp;amp; = \sqrt{n} \epsilon^{\text{abs}} + \epsilon^{\text{rel}} \|A^Ty^k\|_2 \\
\|r^k\|_2 \leq \epsilon^{\text{pri}} &amp;amp; = \sqrt{p} \epsilon^{\text{abs}} + \epsilon^{\text{rel}}\max\{\|Ax^k\|_2, \|Bz^k\|, \|c\|_2\} \&lt;br /&gt;
\end{split}
$$&lt;/p&gt;

&lt;p&gt;上面的$\sqrt{p}$和$\sqrt{n}$分别是维度和样本量。一般而言，相对停止阈值&lt;em&gt;ϵ&lt;/em&gt;&lt;sup&gt;rel&lt;/sup&gt; = 10&lt;sup&gt;−3&lt;/sup&gt;或者10&lt;sup&gt;−4&lt;/sup&gt;，绝对阈值的选取要根据变量取值范围来选取（咋选的呢？没说额，具体比例都不给说-
-！）&lt;/p&gt;

&lt;p&gt;另外一些细节问题，比如原来惩罚参数*ρ*是不变的，一些文献也做了一些可变的惩罚参数，目的是为了降低对于惩罚参数初始值的依赖性。不过变动的*ρ*会导致ADMM的收敛性证明比较困难，因此实际中假设经过一系列迭代后*ρ*也稳定，边可直接用固定的惩罚参数*ρ*了。还有其他问题，诸如*x*与*z*迭代顺序问题，实际操作下有所有不同，这些不是特别重要之处，可以忽略。其他与ADMM比较相关算法的有dual
ADMM算法，distributed ADMM算法，还有整合了ADMM与proximal method of
multiplier的算法&lt;/p&gt;

&lt;h3 id=&#34;2-3-admm一般形式与部分具体应用&#34;&gt;2.3 ADMM一般形式与部分具体应用&lt;/h3&gt;

&lt;p&gt;当构造了ADMM算法中的&lt;em&gt;f&lt;/em&gt;, &lt;em&gt;g&lt;/em&gt;, &lt;em&gt;A&lt;/em&gt;, *B*后，便可直接应用该算法了。我们会经常遇到如下三种一般形式的问题&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;二次目标优化项（quadratic objective terms）；&lt;/li&gt;
&lt;li&gt;可分的目标函数和约束（separable objective and constraints）；&lt;/li&gt;
&lt;li&gt;光滑目标函数项（smooth objective terms）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为下面讨论的方便，下面仅写出&lt;em&gt;x&lt;/em&gt;-update的形式，根据ADMM简化形式，&lt;em&gt;z&lt;/em&gt;-update对称更新即可：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;x&lt;/em&gt;&lt;sup&gt;+&lt;/sup&gt; = argmin&lt;sub&gt;&lt;em&gt;x&lt;/em&gt;&lt;/sub&gt;(&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)+(&lt;em&gt;ρ&lt;/em&gt;/2)∥*A&lt;strong&gt;x* − *v*∥&lt;sub&gt;2&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt;),*v* = −*B&lt;/strong&gt;z* + *c* − &lt;em&gt;u&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;上述更新*x*时候*z*和*u*都定下来，是个常数，*z*更新时后相同。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Proximity Operator（近邻算子）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上述形式有种特殊情况：当*A* = *I*时，即约束条件没有*x*的线性组合形式，只是对于*x*的可行区域进行限制。这种问题相当常见，目前统计学习也有不少类似的高维优化问题。此时&lt;em&gt;x&lt;/em&gt;-update如下&lt;/p&gt;

&lt;p&gt;&lt;em&gt;x&lt;/em&gt;&lt;sup&gt;+&lt;/sup&gt; = argmin&lt;sub&gt;&lt;em&gt;x&lt;/em&gt;&lt;/sub&gt;(&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)+(&lt;em&gt;ρ&lt;/em&gt;/2)∥*x* − *v*∥&lt;sub&gt;2&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt;),*v* = −*B**z* + *c* − &lt;em&gt;u&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;上述右边可以写成*v*的函数&lt;strong&gt;prox&lt;/strong&gt;&lt;sub&gt;&lt;em&gt;f&lt;/em&gt;, &lt;em&gt;ρ&lt;/em&gt;&lt;/sub&gt;(&lt;em&gt;v&lt;/em&gt;)被称作带惩罚*ρ*的*f*的proximity
operator（通常称作proximal
minimization，近邻最小化），在变分分析中，还被称作*f*的&lt;strong&gt;Moreau-Yosida正则化&lt;/strong&gt;。如果*f*形式很简单，可以写出&lt;em&gt;x&lt;/em&gt;-update的解析解，比如*f*是非空的凸包𝒞上的示性函数，那么&lt;em&gt;x&lt;/em&gt;-update就可以直接写成投影形式&lt;/p&gt;

&lt;p&gt;&lt;em&gt;x&lt;/em&gt;&lt;sup&gt;+&lt;/sup&gt; = argmin&lt;sub&gt;&lt;em&gt;x&lt;/em&gt;&lt;/sub&gt;(&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)+(&lt;em&gt;ρ&lt;/em&gt;/2)∥*x* − *v*∥&lt;sub&gt;2&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt;)=&lt;em&gt;Π&lt;/em&gt;&lt;sub&gt;𝒞&lt;/sub&gt;(&lt;em&gt;v&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;投影与惩罚参数*ρ*无关。若*f*是非负象限
&lt;strong&gt;R&lt;/strong&gt;&lt;sub&gt;+&lt;/sub&gt;&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt;
的投影，则直接有
&lt;em&gt;x&lt;/em&gt;&lt;sup&gt;+&lt;/sup&gt; = (&lt;em&gt;v&lt;/em&gt;)&lt;sub&gt;+&lt;/sub&gt;
。&lt;/p&gt;

&lt;p&gt;下面再谈谈上述提到的三种一般形式的优化问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）Quadratic Objective Terms&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设*f*是如下（凸）的二次函数&lt;/p&gt;

&lt;p&gt;$$
f(x) = \frac{1}{2}x^TPx + q^T x + r
$$&lt;/p&gt;

&lt;p&gt;*P*是对称的半正定矩阵*P* ∈ &lt;strong&gt;S&lt;/strong&gt;&lt;sub&gt;+&lt;/sub&gt;&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt;。这种形式问题也包含了*f*是线性或者常数的特殊情况。若*P* + *ρ*&lt;em&gt;A&lt;/em&gt;&lt;sup&gt;&lt;em&gt;T&lt;/em&gt;&lt;/sup&gt;*A*可逆，那么&lt;em&gt;x&lt;/em&gt;-update步求个导即有如下的显示解，是*v*的仿射函数&lt;/p&gt;

&lt;p&gt;&lt;em&gt;x&lt;/em&gt;&lt;sup&gt;+&lt;/sup&gt; = (*P* + *ρ&lt;strong&gt;A*&lt;sup&gt;&lt;em&gt;T&lt;/em&gt;&lt;/sup&gt;&lt;em&gt;A&lt;/em&gt;)&lt;sup&gt;−1&lt;/sup&gt;(*ρ&lt;/strong&gt;A*&lt;sup&gt;&lt;em&gt;T&lt;/em&gt;&lt;/sup&gt;*v* − &lt;em&gt;q&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;因此在&lt;em&gt;x&lt;/em&gt;-minnimiztion步只需要做两个矩阵运算即可，求逆与乘积，选用合适的线性运算库即可以得到不错的计算性能。当然还可以利用一些矩阵分解技巧，这个要看矩阵大小和稀疏程度。因为对于*F**x* = *g*，可以将*F* = &lt;em&gt;F&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;em&gt;F&lt;/em&gt;&lt;sub&gt;2&lt;/sub&gt;⋯&lt;em&gt;F&lt;/em&gt;&lt;sub&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sub&gt;，然后&lt;em&gt;F&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;&lt;em&gt;z&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt; = &lt;em&gt;z&lt;/em&gt;&lt;sub&gt;*i* − 1&lt;/sub&gt;, &lt;em&gt;z&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt; = &lt;em&gt;F&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;sup&gt;−1&lt;/sup&gt;&lt;em&gt;g&lt;/em&gt;, *x* = &lt;em&gt;z&lt;/em&gt;&lt;sub&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sub&gt;，这样会更节省计算时间。其他矩阵计算技巧，基本都是如何对矩阵大规模求解，利用矩阵的稀疏性、缓存分解等来提高性能。此处不赘述，有个很重要的求逆的定理很有用：&lt;/p&gt;

&lt;p&gt;(*P* + *ρ&lt;strong&gt;A*&lt;sup&gt;&lt;em&gt;T&lt;/em&gt;&lt;/sup&gt;&lt;em&gt;A&lt;/em&gt;)&lt;sup&gt;−1&lt;/sup&gt; = &lt;em&gt;P&lt;/em&gt;&lt;sup&gt;−1&lt;/sup&gt; − *ρ&lt;/strong&gt;P*&lt;sup&gt;−1&lt;/sup&gt;&lt;em&gt;A&lt;/em&gt;&lt;sup&gt;&lt;em&gt;T&lt;/em&gt;&lt;/sup&gt;(*I* + *ρ&lt;strong&gt;A&lt;/strong&gt;P*&lt;sup&gt;−1&lt;/sup&gt;&lt;em&gt;A&lt;/em&gt;&lt;sup&gt;&lt;em&gt;T&lt;/em&gt;&lt;/sup&gt;)&lt;sup&gt;−1&lt;/sup&gt;*A*&lt;em&gt;P&lt;/em&gt;&lt;sup&gt;−1&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;如果对于上述二次函数受限于某仿射集&lt;em&gt;x&lt;/em&gt;-update步就更复杂些，如&lt;/p&gt;

&lt;p&gt;$$f(x) = \frac{1}{2}x^T Px + q^T x + r \quad \textbf{dorm} \,f=\{x \| Fx = g\}$$&lt;/p&gt;

&lt;p&gt;&lt;em&gt;x&lt;/em&gt;-update还有个重要的KKT方程可用：&lt;/p&gt;

&lt;p&gt;$$
\begin{pmatrix}
P + \rho I &amp;amp; F^T \&lt;br /&gt;
F &amp;amp; 0 \&lt;br /&gt;
\end{pmatrix}
\begin{pmatrix}
x^{k + 1}\&lt;br /&gt;
v \&lt;br /&gt;
\end{pmatrix}
+
\begin{pmatrix}
q - \rho(z^k - u^k) \&lt;br /&gt;
-g \&lt;br /&gt;
\end{pmatrix}
= 0
$$&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）Smooth Objective Terms&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当*f*光滑时，那么求导即成为可能了。对于一些非线性优化问题，包含梯度算法等方法的L-BFGS算法可以用。对于该算法有些小技巧如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;早终止（early
termination）：当&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)+(&lt;em&gt;ρ&lt;/em&gt;/2)∥*A**x* − *v*∥&lt;sub&gt;2&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt;梯度很小时，早点终止迭代，否则后面就很慢了。&lt;/li&gt;
&lt;li&gt;热启动（warm start）：即启动迭代时，利用之前迭代过的值带入即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;（3）Separable objective and constraints&lt;/strong&gt;
可分函数和约束对于并行计算和分布式计算来说是一个好消息。如果&lt;em&gt;A&lt;/em&gt;&lt;sup&gt;&lt;em&gt;T&lt;/em&gt;&lt;/sup&gt;*A*是分块的对角阵，那么约束中∥*A&lt;strong&gt;x*∥&lt;sub&gt;2&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt;也是可分的，则扩增的拉格朗日函数&lt;em&gt;L&lt;/em&gt;&lt;sub&gt;&lt;em&gt;ρ&lt;/em&gt;&lt;/sub&gt;也是可分的。（注意，此处是指函数中的参数可分成小子块，而不是说数据可分。）下面有一个很重要的例子，即&lt;/strong&gt;soft
thresholding**（针对&lt;em&gt;l&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt; + &lt;em&gt;l&lt;/em&gt;&lt;sub&gt;2&lt;/sub&gt;问题）:&lt;/p&gt;

&lt;p&gt;当&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)=*λ*∥*x*∥&lt;sub&gt;1&lt;/sub&gt;, *λ* &amp;gt; 0，并且*A* = *I*时，那么&lt;em&gt;x&lt;/em&gt;-update就变成了&lt;/p&gt;

&lt;p&gt;&lt;em&gt;x&lt;/em&gt;&lt;sup&gt;+&lt;/sup&gt; = argmin&lt;sub&gt;&lt;em&gt;x&lt;/em&gt;&lt;/sub&gt;(*λ*∥&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;∥+(&lt;em&gt;ρ&lt;/em&gt;/2)∥*x* − *v*∥&lt;sub&gt;2&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt;)&lt;/p&gt;

&lt;p&gt;这种形式很常见在目前的高维统计中，虽然第一项在0处不可导，但是也有解析解，被称作软阈值（soft
thresholding），也被称作压缩算子（shrinkage operator）。&lt;/p&gt;

&lt;p&gt;$$
x^{+}_i = S_{\lambda/\rho}(v_i),
\rightarrow
S_k(a) = \left\{
\begin{array}{lc}
a - k &amp;amp;, a &amp;gt;k \&lt;br /&gt;
0, &amp;amp; |a|\leq k\&lt;br /&gt;
a +k &amp;amp; a &amp;lt; -k \&lt;br /&gt;
\end{array}
\right.
\rightarrow
S_k(a) = (1 - \frac{k}{|a|})_{+}a
$$&lt;/p&gt;

&lt;p&gt;在优化领域，软阈值被称作是ℓ&lt;sub&gt;1&lt;/sub&gt;-norm问题的近邻算子（proximity
operator）。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;一些具体优化应用
&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;3-1受约束的凸优化问题&#34;&gt;3.1受约束的凸优化问题&lt;/h3&gt;

&lt;p&gt;一般的受约束的凸优化问题可以写成如下形式&lt;/p&gt;

&lt;p&gt;$$
\begin{array}{lc}
\min &amp;amp; f(x) \&lt;br /&gt;
s.t &amp;amp; x \in \mathcal{C} \&lt;br /&gt;
\end{array}
$$&lt;/p&gt;

&lt;p&gt;此类问题可以写成ADMM形式&lt;/p&gt;

&lt;p&gt;$$
\begin{array}{lc}
\min &amp;amp; f(x) + g(z)\&lt;br /&gt;
s.t &amp;amp; x - z = 0 \&lt;br /&gt;
\end{array}
\Longrightarrow
L_{\rho}(x, z, u) = f(x) + g(z) + (\rho/2)\|x - z + u\|^2_2
$$&lt;/p&gt;

&lt;p&gt;其中的*g*函数即𝒞的示性函数，上述是scaled形式，那么具体算法就是&lt;/p&gt;

&lt;p&gt;$$
\begin{split}
x^{k+1} &amp;amp; = \arg\min(f(x)+(\rho/2)\|x - z^k + u^k\|^2_2)\&lt;br /&gt;
z^{k+1} &amp;amp; = \Pi_{\mathcal{C}}(x^{k+1} + u^k) \&lt;br /&gt;
u^{k+1} &amp;amp; = u^k + x^{k+1} - z^{k+1} \&lt;br /&gt;
\end{split}
$$&lt;/p&gt;

&lt;p&gt;则上述*x* − *m&lt;strong&gt;i&lt;/strong&gt;n*就变成了一个具体的受约束的优化问题。比如对于经典的二次规划问题(QP)&lt;/p&gt;

&lt;p&gt;$$
\begin{array}{lc}
\min &amp;amp; \frac{1}{2}x^TPx + q^T x \&lt;br /&gt;
s.t &amp;amp; Ax = b, x \geq  0 \&lt;br /&gt;
\end{array}
$$&lt;/p&gt;

&lt;p&gt;写成ADMM形式&lt;/p&gt;

&lt;p&gt;$$
\begin{array}{lc}
\min &amp;amp; f(x) + g(z) \&lt;br /&gt;
s.t &amp;amp; x - z = 0  \&lt;br /&gt;
\end{array}
\Longrightarrow
\begin{split}
f(x) &amp;amp; = \frac{1}{2}x^TPx + q^T x,  \,\, \textbf{dorm}\,f = \{x | Ax = b\} \&lt;br /&gt;
g(z) &amp;amp; = I(\Pi_{R^n_{+}}(z)) \&lt;br /&gt;
\end{split}
$$&lt;/p&gt;

&lt;p&gt;即受约束的区域就是
{*x* ∣ *x* ≥ 0}
，*g*是向非负象限投影的示性函数。而&lt;em&gt;x&lt;/em&gt;-update就变成了之前在Quadratic
Objective
Terms中谈到的&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)有仿射集定义域的优化问题，根据KKT条件即可写出来&lt;em&gt;x&lt;/em&gt;-update更新的形式，参见2.3节。&lt;/p&gt;

&lt;p&gt;如果上述对*x*限制不是限制*x* ≥ 0上，而是一个锥约束（conic
constraint）*x* ∈ 𝒦，那么&lt;em&gt;x&lt;/em&gt;-update不变，继续上述KKT方程，而只需要变一下&lt;em&gt;z&lt;/em&gt;-update，将向
&lt;em&gt;R&lt;/em&gt;&lt;sub&gt;+&lt;/sub&gt;&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt;
投影改成向𝒦投影。比如将上述约束改成
$$\{Ax = b, x \in \S^n_{+}\}$$
，即*x*属于半正定空间，那么向&lt;em&gt;S&lt;/em&gt;&lt;sub&gt;+&lt;/sub&gt;&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt;投影就变成了一个半正定问题，利用特征值分解可以完成。&lt;strong&gt;这种受约束的凸优化问题的形式化对后续许多问题，特别是我们很关注的ℓ&lt;sub&gt;1&lt;/sub&gt;-norm问题很重要，基本上都是转化成这种形式来直接应用ADMM算法，所以这里要好好把握其核心思想和形式。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;虽然我对优化不在行，但是感觉优化问题还是挺有意思的，下面是一个经典问题，即找到两个非空凸包的交集中的一点。该算法都可以追溯到1930年代的Neumann交替投影算法（alternating
projections algorithm）：&lt;/p&gt;

&lt;p&gt;$$
\begin{split}
x^{k + 1} &amp;amp; = \Pi_{\mathcal{C}}(z^k) \&lt;br /&gt;
z^{k + 1} &amp;amp; = \Pi_{\mathcal{D}}(x^{k + 1}) \&lt;br /&gt;
\end{split}
$$&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Π&lt;/em&gt;&lt;sub&gt;𝒞&lt;/sub&gt;, &lt;em&gt;Π&lt;/em&gt;&lt;sub&gt;𝒟&lt;/sub&gt;
分别是两个集合的欧式空间投影。写成ADMM形式就是&lt;/p&gt;

&lt;p&gt;$$
\begin{split}
x^{k + 1} &amp;amp; = \Pi_{\mathcal{C}}(z^k - u^k) \&lt;br /&gt;
z^{k + 1} &amp;amp; = \Pi_{\mathcal{D}}(x^{k + 1} + u^k) \&lt;br /&gt;
u^{k + 1} &amp;amp; = u^k + x^{k + 1} - z^{k + 1} \&lt;br /&gt;
\end{split}
$$&lt;/p&gt;

&lt;p&gt;上述问题还可推广至找到*N*个非空凸包交集中一个点的问题，这样其实在*x*步是可以并行来做的，于是就有&lt;/p&gt;

&lt;p&gt;$$
\begin{split}
x_i^{k + 1} &amp;amp; = \Pi_{\mathcal{A}_i}(z^k - u_i^k) \&lt;br /&gt;
z^{k + 1} &amp;amp; = \frac{1}{N}\sum^N_{i=1}(x_i^{k + 1} + u_i^k) \\
u_i^{k + 1} &amp;amp; = u_i^k + x_i^{k + 1} - z^{k + 1} \&lt;br /&gt;
\end{split}
\Longrightarrow u_i\text{收敛均趋向于0}, z^{k+1} = \bar{x}^{k + 1}
\begin{split}
x_i^{k + 1} &amp;amp; = \Pi_{\mathcal{A}_i}(\bar{x}^k - u_i^k) \&lt;br /&gt;
u_i^{k + 1} &amp;amp; = u_i^k + (x_i^{k + 1} - \bar{x}^{k + 1}) \&lt;br /&gt;
\end{split}
$$&lt;/p&gt;

&lt;h3 id=&#34;3-2-ℓ-sub-1-sub-norm问题&#34;&gt;3.2 ℓ&lt;sub&gt;1&lt;/sub&gt;-norm问题&lt;/h3&gt;

&lt;p&gt;高维统计理论的发展，如果要追溯起来我觉得可以从Lasso解法算起，类似的思想在往前追可能是Huber相关的工作。是对于lasso问题，由于当年大家还没搞清楚lasso和boosting之间关系，对于sparsity性质不了解，谁也不知道如何很好地解决这个问题。直到后面Efron提出了LARS算法，对两者的路径解相似性做了很好的阐述，于是后面关于变量选择，关于basis-pursuit，compressed
sensing，sparse graphical
models等各种新问题的产生，随后各种优化算法也随之涌现出来，诸如Gradient
Projection， Proximal methods，ADMM (Alternating Direction Method of
Multipliers)， (Split) Bregman methods，Nesterov’s
method。不过要能够大规模部署ℓ&lt;sub&gt;1&lt;/sub&gt;-norm的解决方案，那么这些算法中ADMM可能是首选。此处ℓ&lt;sub&gt;1&lt;/sub&gt;-norm问题并不仅仅指Lasso问题，包含了多种ℓ&lt;sub&gt;1&lt;/sub&gt;-norm类型问题。下面均介绍下。&lt;/p&gt;

&lt;p&gt;之所以说ADMM适合机器学习和统计学习的优化问题，因为大部分机器学习问题基本都是“损失函数+正则项”形式，这种分法恰好可以套用到ADMM的框架&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)+&lt;em&gt;g&lt;/em&gt;(&lt;em&gt;z&lt;/em&gt;)。因此结合ADMM框架基本可以解决很多已有的问题，以及利用ℓ&lt;sub&gt;1&lt;/sub&gt;-norm构造的新的优化问题。下面将先介绍非分布式计算的版本，后面会单开一节来介绍如何分布式计算。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）Least Absolute Deviations&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;先从一个简单的问题开始。在稳健估计中，LAD是一个应用很广的模型，相对于直接优化平方和损失∥*A&lt;strong&gt;x* − *b*∥&lt;sub&gt;2&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt;，优化绝对损失∥*A&lt;/strong&gt;x* − *b*∥&lt;sub&gt;1&lt;/sub&gt;，它的抗噪性能更好。在ADMM框架下，往之前的受约束的凸优化问题靠拢，这个问题有简单的迭代算法&lt;/p&gt;

&lt;p&gt;$$
\begin{array}{lc}
\min &amp;amp; \|z\|_1 \&lt;br /&gt;
s.t. &amp;amp; Ax - b = z \&lt;br /&gt;
\end{array}
\Longrightarrow \text{let} \,\,f(x) = 0, g(z) = \|z\|_1
\Longrightarrow
\begin{split}
x^{k + 1} &amp;amp; = (A^TA)^{-1}A^T(b + z^k - u^k) \&lt;br /&gt;
z^{k + 1} &amp;amp; = S_{1/\rho}(Ax^{k + 1} - b + u^k) \&lt;br /&gt;
u^{k + 1} &amp;amp; = u^k + Ax^{k+1} - z^{k + 1} - b \&lt;br /&gt;
\end{split}
$$&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）Huber fitting&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Huber问题与上面的其实差不多，只是损失函数形式不同，换成了Huber惩罚函数&lt;/p&gt;

&lt;p&gt;$$
\begin{array}{lc}
\min &amp;amp; g^{hub}(z) \&lt;br /&gt;
s.t. &amp;amp; Ax - b = z \&lt;br /&gt;
\end{array}
, \,\, g^{hub}(z) = \left\{
\begin{array}{lc}
z^&lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;, &amp;amp; |z| \leq 1 \&lt;br /&gt;
|z| - \frac{1}{2} &amp;amp; |z| &amp;gt; 1 \&lt;br /&gt;
\end{array}
\right.
$$&lt;/p&gt;

&lt;p&gt;因此与LAD除了&lt;em&gt;z&lt;/em&gt;-update不在是proximity
operator（或称作软阈值）之外，其余均是相同的&lt;/p&gt;

&lt;p&gt;$$z^{k + 1} = \frac{\rho}{1 + \rho}(Ax^{k + 1} - b + u^k) + \frac{1}{1 + \rho}S_{1 + 1/\rho}(Ax^{k+1} - b + u^k)$$&lt;/p&gt;

&lt;p&gt;看着像是proximity operator与一个残差的加权。&lt;/p&gt;

&lt;p&gt;LAD和Huber
fitting这种问题只是一些传统损失不加正则项的ADMM化，注意一定要构造个*z*出来即可，*x*可以基本不用管，总是需要解的，下面的带有正则项的优化问题，ADMM形式就会更明显。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）Basis Pursuit&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;基追踪法师系数信号处理的一种重要方法。目的是想找到一组稀疏基可以完美恢复信号，换套话说就是为一个线性方程系统找到一个稀疏解。原始形式如下，与lasso有些像：&lt;/p&gt;

&lt;p&gt;$$
\begin{array}{lc}
\min &amp;amp; \|x\|_1 \&lt;br /&gt;
s.t. &amp;amp; Ax = b \&lt;br /&gt;
\end{array}
$$&lt;/p&gt;

&lt;p&gt;修改成ADMM形式，注意往之前受约束的凸优化问题的那种形式回套，将ℓ&lt;sub&gt;1&lt;/sub&gt;看做约束，然后构造带定义域的&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)，于是就有解&lt;/p&gt;

&lt;p&gt;$$
\begin{array}{lc}
\min &amp;amp; f(x) + \|z\|_1 \&lt;br /&gt;
s.t. &amp;amp; x - z = 0 \&lt;br /&gt;
\end{array}
\,\,\,
f(x) = I(\{x \in \mathbf{R}^n| Ax = b\}) \,\, \text{indicator function}
\Longrightarrow
\begin{split}
x^{k + 1} &amp;amp; = \Pi(z^k - u^k) \&lt;br /&gt;
z^{k + 1} &amp;amp; = S_{1/\rho}(Ax^{k + 1} +  u^k) \&lt;br /&gt;
u^{k + 1} &amp;amp; = u^k + x^{k+1} - z^{k + 1} \&lt;br /&gt;
\end{split}
$$&lt;/p&gt;

&lt;p&gt;其中&lt;em&gt;Π&lt;/em&gt;(&lt;em&gt;z&lt;/em&gt;&lt;sup&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sup&gt; − &lt;em&gt;u&lt;/em&gt;&lt;sup&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sup&gt;)是向一个线性约束的欧式空间中投影{*x* ∈ &lt;em&gt;R&lt;/em&gt;&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt; ∣ *A**x* = &lt;em&gt;b&lt;/em&gt;}，这也是有直接的显示解的&lt;/p&gt;

&lt;p&gt;&lt;em&gt;x&lt;/em&gt;&lt;sup&gt;*k* + 1&lt;/sup&gt; = (*I* − &lt;em&gt;A&lt;/em&gt;&lt;sup&gt;&lt;em&gt;T&lt;/em&gt;&lt;/sup&gt;(&lt;em&gt;A&lt;/em&gt;&lt;sup&gt;&lt;em&gt;T&lt;/em&gt;&lt;/sup&gt;&lt;em&gt;A&lt;/em&gt;)&lt;sup&gt;−1&lt;/sup&gt;&lt;em&gt;A&lt;/em&gt;)(*z* − &lt;em&gt;u&lt;/em&gt;&lt;sup&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sup&gt;)+&lt;em&gt;A&lt;/em&gt;&lt;sup&gt;&lt;em&gt;T&lt;/em&gt;&lt;/sup&gt;(*A*&lt;em&gt;A&lt;/em&gt;&lt;sup&gt;&lt;em&gt;T&lt;/em&gt;&lt;/sup&gt;)&lt;sup&gt;−1&lt;/sup&gt;&lt;em&gt;b&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;对于矩阵求逆、分解等用之前矩阵那些小技巧即可加快计算，节省计算资源。&lt;/p&gt;

&lt;p&gt;最近还有一类算法来解决ℓ&lt;sub&gt;1&lt;/sub&gt;问题，被称作&lt;strong&gt;Bregman iteration
methods&lt;/strong&gt;，对于基追踪相关问题，加正则项的Bregman iteration就是method of
multiplier，而所谓的split Bregman iteration就等同于
ADMM。我没有继续深究，应该就是类似于并行化的ADMM算法来解决基追踪问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（4）一般化的损失函数 + ℓ&lt;sub&gt;1&lt;/sub&gt;正则项问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这类问题在高维统计开始时便是一个非常重要的问题，而即使到了现在也是一个非常重要的问题，比如group
lasso，generalized
lasso，高斯图模型，Tensor型图模型，与图相关的ℓ&lt;sub&gt;1&lt;/sub&gt;问题等算法的开发，都可以在此框架上直接应用和实施，这正是ADMM一个优势所在，便于快速实施，也便于可能的大规模分布式部署。&lt;/p&gt;

&lt;p&gt;$$
\min \,\, l(x) + \lambda\|x\|_1,
\Longrightarrow
\begin{array}{lc}
\min &amp;amp; l(x) + g(z) = l(x) + \lambda \|z\|_1 \&lt;br /&gt;
s.t. &amp;amp; x - z = 0 \&lt;br /&gt;
\end{array}
\Longrightarrow
\begin{split}
x^{k + 1} &amp;amp; = \arg\min_x (l(x) + (\rho/2)\|x - z^k + u^k\|_2^2) \&lt;br /&gt;
z^{k + 1} &amp;amp; = S_{1/\rho}(x^{k + 1} +  u^k) \&lt;br /&gt;
u^{k + 1} &amp;amp; = u^k + x^{k+1} - z^{k + 1} \&lt;br /&gt;
\end{split}
$$&lt;/p&gt;

&lt;p&gt;可以看到与Basis Pursuit解法只是在&lt;em&gt;x&lt;/em&gt;-update上有区别：Basis
Pursuit是构造出来一个投影函数&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)，而一般化的损失函数&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)+ℓ&lt;sub&gt;1&lt;/sub&gt;正则项问题，用ADMM就更为自然。所以很适合作为框架来解决这一类问题：广义线性模型（普通线性、logistic回归、possion回归、softmax回归）+正则项；广义可加模型+正则项；似然函数（高斯图方向）+正则项。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Lasso&lt;/strong&gt;：$f(x) = \frac{1}{2}\|Ax - b\|^2_2$，于是利用ADMM算法，&lt;em&gt;x&lt;/em&gt;-update的解析解就是&lt;em&gt;x&lt;/em&gt;&lt;sup&gt;*k* + 1&lt;/sup&gt; = (&lt;em&gt;A&lt;/em&gt;&lt;sup&gt;&lt;em&gt;T&lt;/em&gt;&lt;/sup&gt;*A* + *ρ*&lt;em&gt;I&lt;/em&gt;)&lt;sup&gt;−1&lt;/sup&gt;(&lt;em&gt;A&lt;/em&gt;&lt;sup&gt;&lt;em&gt;T&lt;/em&gt;&lt;/sup&gt;*b* + &lt;em&gt;ρ&lt;/em&gt;(&lt;em&gt;z&lt;/em&gt;&lt;sup&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sup&gt; − &lt;em&gt;u&lt;/em&gt;&lt;sup&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sup&gt;))；于是&lt;em&gt;x&lt;/em&gt;-update看起来是个岭回归了，因此ADMM对于lasso可以看做迭代的使用岭回归。至于矩阵求逆那些，利用之前的矩阵小技巧解决。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Generalized
lasso&lt;/strong&gt;：这个问题可能不是那么为众人所熟悉，他是Tibs的儿子搞出来的框罗类似fused
lasso这种事先定义好的线性变化的惩罚项的模型，损失函数是平方损失，而惩罚变成了一个特殊的参数线性组合&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$$
\min \frac{1}{2}\|Ax - b\|^2_2 + \lambda\|Fx\|_1
$$
$$
\Longrightarrow
\text{1d fused lasso}, \,\, A = I \,\,
F_{ij} = \left\{
\begin{array}{lc}
1 &amp;amp; j = i + 1\&lt;br /&gt;
-1 &amp;amp; j = i \&lt;br /&gt;
0 &amp;amp; \text{otherwise} \&lt;br /&gt;
\end{array}
\right.
$$&lt;/p&gt;

&lt;p&gt;$$
\Longrightarrow
\min \frac{1}{2}\|x - b\|^2_2 + \lambda \sum^{n-1}_{i = 1}|x_{i + 1} - x_i|
\Longrightarrow
A = I, F \,\,\text{二阶差分矩阵，则被称作L1 trend filtering}
$$&lt;/p&gt;

&lt;p&gt;若将上述这种写成ADMM形式，同样可以放到ADMM算法框架中解决&lt;/p&gt;

&lt;p&gt;$$
\begin{array}{lc}
\min &amp;amp; \frac{1}{2}\|Ax-b\|^2_2 + \lambda \|z\|_1 \&lt;br /&gt;
s.t. &amp;amp; Fx - z = 0 \&lt;br /&gt;
\end{array}
\Longrightarrow
\begin{split}
x^{k + 1} &amp;amp; = (A^TA + \rho F^TF)^{-1}(A^Tb + \rho F^T(z^k - u^k)) \&lt;br /&gt;
z^{k + 1} &amp;amp; = S_{1/\rho}(Ax^{k + 1} - b + u^k) \&lt;br /&gt;
u^{k + 1} &amp;amp; = u^k + Fx^{k+1} - z^{k + 1} - b \&lt;br /&gt;
\end{split}
$$&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Group lasso&lt;/strong&gt;：graph
lasso问题应用比较广，对不同组的参数同时进行惩罚，进行一组组参数的挑选，故曰group
lasso。不同于lasso，其正则项变成了$\sum^N_{i = 1}\|x_i\|_2, x_i \in \mathbf{R}^{n_i}$，lasso其实是group
lasso的一种特殊形式。正则项并不是完全可分的。此时只是&lt;em&gt;z&lt;/em&gt;-update变成了block的软阈值形式&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$$
z^{k+1}_i = S_{\lambda/rho}(x^{k+1}_i + u^k), i = 1,\ldots, N
\Longrightarrow
S_{k}(a) = (1 - \frac{k}{\|a\|_2})_{+}a, S(0)=0
$$&lt;/p&gt;

&lt;p&gt;这种形式还可以扩展到group间有重合的情况，即化成*N*可能存在重合的组&lt;em&gt;G&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt; ⊆ {1, …, &lt;em&gt;n&lt;/em&gt;}。一般来说这种问题会非常难解决，但是对于ADMM算法只需要换下形式就很直接（&lt;em&gt;x&lt;/em&gt;, *z*互换，会变成后面非常重要的一致性优化问题（consensus
optimization），局部&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;与全局真解*z*子集$\hat{z}_i$的对应。）&lt;/p&gt;

&lt;p&gt;$$
\begin{array}{lc}
\min &amp;amp; \frac{1}{2}\|Az - b\|^2_2 + \lambda \sum^N_{i = 1}\|x_i\|_2, x_i \in \mathbf{R}^{|G_i|} \&lt;br /&gt;
s.t. &amp;amp; x_i - \hat{z}_i = 0, i = 1, \ldots, N \&lt;br /&gt;
\end{array}
$$&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Sparse Gaussian graph
model&lt;/strong&gt;：对于稀疏高斯图，熟悉该问题的人知道这其实是lasso的图上的推广，损失函数写成似然函数的负数即可
&lt;em&gt;l&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)=&lt;strong&gt;tr&lt;/strong&gt;(*S*&lt;em&gt;X&lt;/em&gt;)−logdet&lt;em&gt;X&lt;/em&gt;, *X* ∈ &lt;em&gt;S&lt;/em&gt;&lt;sub&gt;++&lt;/sub&gt;&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt;
。于是原来向量的操作就变成了矩阵操作，ADMM算法也有点变化：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$$
\begin{split}
X^{k + 1} &amp;amp; = \arg\min_X (\textbf{tr}(SX) - \log\det X + \frac{\rho}{2}\|X - Z^k + U^k\|_F)\&lt;br /&gt;
Z^{k + 1} &amp;amp; = \arg\min_Z(\lambda\|Z\|_1 + \frac{\rho}{2}\|X^{k+1} - Z + U^k\|_F) \&lt;br /&gt;
U^{k + 1} &amp;amp; = U^k + X^{k+1} - Z^{k + 1} \&lt;br /&gt;
\end{split}
$$&lt;/p&gt;

&lt;p&gt;上述算法继续化简，对于&lt;em&gt;z&lt;/em&gt;-update做逐个元素软阈值操作即可
&lt;em&gt;Z&lt;/em&gt;&lt;sub&gt;*i&lt;strong&gt;j*&lt;/sub&gt;&lt;sup&gt;*k* + 1&lt;/sup&gt; = &lt;em&gt;S&lt;/em&gt;&lt;sub&gt;&lt;em&gt;λ&lt;/em&gt;/&lt;em&gt;ρ&lt;/em&gt;&lt;/sub&gt;(&lt;em&gt;X&lt;/em&gt;&lt;sub&gt;*i&lt;/strong&gt;j*&lt;/sub&gt;&lt;sup&gt;*K* + 1&lt;/sup&gt; + &lt;em&gt;U&lt;/em&gt;&lt;sub&gt;*i*&lt;em&gt;j&lt;/em&gt;&lt;/sub&gt;&lt;sup&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sup&gt;)
。对于&lt;em&gt;x&lt;/em&gt;-update也类似操作，直接求导一阶导为0，移项后对对称矩阵做特征值分解即可&lt;/p&gt;

&lt;p&gt;*ρ&lt;strong&gt;X* − &lt;em&gt;X&lt;/em&gt;&lt;sup&gt;−1&lt;/sup&gt; = &lt;em&gt;ρ&lt;/em&gt;(&lt;em&gt;Z&lt;/em&gt;&lt;sup&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sup&gt; − &lt;em&gt;U&lt;/em&gt;&lt;sup&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sup&gt;)−*S* = *Q&lt;/strong&gt;Λ&lt;strong&gt;Q*&lt;sup&gt;&lt;em&gt;T&lt;/em&gt;&lt;/sup&gt;, *Q&lt;/strong&gt;Q*&lt;sup&gt;&lt;em&gt;T&lt;/em&gt;&lt;/sup&gt; = &lt;em&gt;I&lt;/em&gt;, *Λ* = &lt;strong&gt;diag&lt;/strong&gt;(&lt;em&gt;λ&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;, …, &lt;em&gt;λ&lt;/em&gt;&lt;sub&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sub&gt;)
$$
\rightarrow
\rho \hat{X} - \hat{X}^{-1} = \Lambda, \hat{X} = Q^TXQ
$$&lt;/p&gt;

&lt;p&gt;由于*Λ*是对角阵，对于每个对角元素来说，上述问题就是解一个二次方程，解方程后，再将$\hat{X}$变化成*X*即可&lt;/p&gt;

&lt;p&gt;$$
\hat{X}_{ii} = \frac{\lambda_i + \sqrt{\lambda_i^2 + 4 \rho}}{2\rho}
\Longrightarrow
X = Q\hat{X}Q^T
$$&lt;/p&gt;

&lt;p&gt;总之，上述跟ℓ&lt;sub&gt;1&lt;/sub&gt;相关的问题，基本都可以纳入ADMM框架，并且可以快速求解。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Consensus and Sharing
&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;本节讲述的两个优化问题，是非常常见的优化问题，也非常重要，我认为是ADMM算法通往并行和分布式计算的一个途径：consensus和sharing，即一致性优化问题与共享优化问题。&lt;/p&gt;

&lt;h2 id=&#34;consensus&#34;&gt;Consensus&lt;/h2&gt;

&lt;h3 id=&#34;4-1-全局变量一致性优化-global-variable-consensus-optimization-切割数据-参数-变量-维数相同&#34;&gt;4.1 全局变量一致性优化（Global variable consensus optimization）（切割数据，参数（变量）维数相同）&lt;/h3&gt;

&lt;p&gt;所谓全局变量一致性优化问题，即目标函数根据数据分解成*N*子目标函数（子系统），每个子系统和子数据都可以获得一个参数解&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;，但是全局解只有一个*z*，于是就可以写成如下优化命题：&lt;/p&gt;

&lt;p&gt;$$
\begin{array}{lc}
\min &amp;amp; \sum^N_{i = 1}f_i(x_i), x_i \in \mathbf{R}^n\&lt;br /&gt;
s.t. &amp;amp; x_i - z = 0 \&lt;br /&gt;
\end{array}
$$&lt;/p&gt;

&lt;p&gt;注意，此时&lt;em&gt;f&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt; : &lt;strong&gt;R&lt;/strong&gt;&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt; → &lt;strong&gt;R&lt;/strong&gt;⋃{ + ∞}仍是凸函数，而&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;并不是对参数空间进行划分，这里是对数据而言，所以&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;维度一样&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;, *z* ∈ &lt;strong&gt;R&lt;/strong&gt;&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt;，与之前的问题并不太一样。这种问题其实就是所谓的并行化处理，或分布式处理，希望从多个分块的数据集中获取相同的全局参数解。&lt;/p&gt;

&lt;p&gt;在ADMM算法框架下（先返回最初从扩增lagrangian导出的ADMM），这种问题解法相当明确：&lt;/p&gt;

&lt;p&gt;$$
\begin{array}{c}
L_{\rho}(x_1, \ldots, x_N, z, y) = \sum^N_{i=1}(f_i(x_i) + y^T_i(x_i - z) + (\rho/2)\|x_i - z\|^2_2) \&lt;br /&gt;
s.t. \mathcal{C} = \{(x_1, \ldots, x_N)|x_1 = \ldots = x_N\} \&lt;br /&gt;
\end{array}
$$&lt;/p&gt;

&lt;p&gt;$$
\Longrightarrow
\begin{split}
x_i^{k+1} &amp;amp; = \arg\min_x (f_i(x_i) + (y^k_i)^T(x_i - z^k) +  (\rho/2)\|x_i - z\|^2_2)) \&lt;br /&gt;
z^{k+1} &amp;amp; = \frac{1}{N}\sum^N_{i=1}(x_i^{k+1} + (\frac{1}{\rho}y^k_i)) \&lt;br /&gt;
y_i^{k+1} &amp;amp; = y_i^k + \rho(x_i^{k+1} - z^{k+1}) \&lt;br /&gt;
\end{split}
$$&lt;/p&gt;

&lt;p&gt;对&lt;em&gt;y&lt;/em&gt;-update和&lt;em&gt;z&lt;/em&gt;-update的&lt;em&gt;y&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;&lt;sup&gt;*k* + 1&lt;/sup&gt;和&lt;em&gt;z&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;&lt;sup&gt;*k* + 1&lt;/sup&gt;分别求个平均，易得$\bar{y}^{k+1}=0$，于是可以知道&lt;em&gt;z&lt;/em&gt;-update步其实可以简化为$z^{k+1} = \bar{x}^{k+1}$，于是上述ADMM其实可以进一步化简为如下形式：&lt;/p&gt;

&lt;p&gt;$$
\begin{split}
x_i^{k+1} &amp;amp; = \arg\min_x (f_i(x_i) + (y^k_i)^T(x_i - \bar{x}^k) + (\rho/2)\|x_i - \bar{x}^k\|^2_2)) \&lt;br /&gt;
y_i^{k+1} &amp;amp; = y_i^k + \rho(x_i^{k+1} - \bar{x}^{k+1}) \&lt;br /&gt;
\end{split}
$$&lt;/p&gt;

&lt;p&gt;这种迭代算法写出来了，并行化那么就是轻而易举了，各个子数据分别并行求最小化，然后将各个子数据的解汇集起来求均值，整体更新对偶变量&lt;em&gt;y&lt;/em&gt;&lt;sup&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sup&gt;，然后再继续回带求最小值至收敛。当然也可以分布式部署（hadoop化），但是说起来容易，真正工程实施起来又是另外一回事，各个子节点机器间的通信更新是一个需要细细揣摩的问题。&lt;/p&gt;

&lt;p&gt;另外，对于全局一致性优化，也需要给出相应的终止迭代准则，与一般的ADMM类似，看primal和dual的residuals即可&lt;/p&gt;

&lt;p&gt;$$
\|r^k\|_2^2 = \sum^N_{i = 1}\|x^k_i - \bar{x}^k\|_2^2, \quad \|s^k\|_2^2 = N\rho\|\bar{x}^k_i - \bar{x}^{k-1}\|_2^2
$$&lt;/p&gt;

&lt;h3 id=&#34;4-2-带正则项的全局一致性问题&#34;&gt;4.2 带正则项的全局一致性问题&lt;/h3&gt;

&lt;p&gt;下面就是要将之前所谈到的经典的机器学习算法并行化起来。想法很简单，就是对全局变量加上正则项即可，因此ADMM算法只需要改变下&lt;em&gt;z&lt;/em&gt;-update步即可&lt;/p&gt;

&lt;p&gt;$$
\begin{array}{lc}
\min &amp;amp; \sum^N_{i = 1}f_i(x_i) + g(z), x_i \in \mathbf{R}^n\&lt;br /&gt;
s.t. &amp;amp; x_i - z = 0 \&lt;br /&gt;
\end{array}
\Longrightarrow
\begin{split}
x_i^{k+1} &amp;amp; = \arg\min_{x+i} (f_i(x_i) + (y^k_i)^T(x_i - z^k) (\rho/2)\|x_i - z\|^2_2)) \&lt;br /&gt;
z^{k+1} &amp;amp; = \arg\min_z (g(z) + \sum^N_{i=1}(-(y^k_i)^Tz + (\rho/2)\|x^{k+1}_i - z\|_2^2)) \&lt;br /&gt;
y_i^{k+1} &amp;amp; = y_i^k + \rho(x_i^{k+1} - z^{k+1})\&lt;br /&gt;
\end{split}
$$&lt;/p&gt;

&lt;p&gt;同样的，我们仍对*z*做一个平均处理，于是就有&lt;/p&gt;

&lt;p&gt;$$z^{k+1} = \arg\min_z(g(z) + (N\rho/2)\|z - \bar{x}^{k+1} - (1/\rho)\bar{y}^k\|^2_2)$$&lt;/p&gt;

&lt;p&gt;上述形式都取得是最原始的ADMM形式，简化处理，写成scaled形式即有&lt;/p&gt;

&lt;p&gt;$$
\begin{split}
x_i^{k+1} &amp;amp; = \arg\min_x (f_i(x_i) + (\rho/2)\|x_i - z^k + u_i^k\|^2_2)) \&lt;br /&gt;
z^{k+1} &amp;amp; = \arg\min_z (g(z) + (N\rho/2)\|z - x^{k+1}_i - \bar{u}^k\|^2_2) \&lt;br /&gt;
u_i^{k+1} &amp;amp; = u_i^k + x_i^{k+1} - z^{k+1} \&lt;br /&gt;
\end{split}
$$&lt;/p&gt;

&lt;p&gt;这样对于后续处理问题就清晰明了多了。可以看到如果&lt;em&gt;g&lt;/em&gt;(&lt;em&gt;z&lt;/em&gt;)=*λ*∥*z*∥&lt;sub&gt;1&lt;/sub&gt;，即lasso问题，那么&lt;em&gt;z&lt;/em&gt;-update步就用软阈值operator即可。因此，对于大规模数据，要想用lasso等算法，只需要对数据做切块（切块也最好切均匀点），纳入到全局变量一致性的ADMM框架中，即可并行化处理。下面给出一些实例。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;切割大样本数据，并行化计算&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在经典的统计估计中，我们处理的多半是大样本低维度的数据，现在则多是是大样本高维度的数据。对于经典的大样本低维度数据，如果机器不够好，那么就抽样部分数据亦可以实现较好估计，不过如果没有很好的信息，就是想要对大样本进行处理，那么切割数据，并行计算是一个好的选择。现在的社交网络、网络日志、无线感应网络等都可以这么实施。下面的具体模型都在受约束的凸优化问题中以及ℓ&lt;sub&gt;1&lt;/sub&gt;-norm问题中提过，此处只不过切割数据，做成分布式模型，思想很简单，与带正则项的global
consensus问题一样的处理。经典问题lasso、sparse logistic
lasso、SVM都可以纳入如下框架处理。&lt;/p&gt;

&lt;p&gt;有观测阵*A* ∈ &lt;strong&gt;R&lt;/strong&gt;&lt;sup&gt;*m* × &lt;em&gt;n&lt;/em&gt;&lt;/sup&gt;和响应值*b* ∈ &lt;strong&gt;R&lt;/strong&gt;&lt;sup&gt;&lt;em&gt;m&lt;/em&gt;&lt;/sup&gt;，可以对应切分，即对矩阵*A*和向量*b*横着切，&lt;/p&gt;

&lt;p&gt;$$
A = \begin{pmatrix}
A_1\&lt;br /&gt;
\vdots\&lt;br /&gt;
A_N \&lt;br /&gt;
\end{pmatrix}
\quad
b = \begin{pmatrix}
b_1 \&lt;br /&gt;
\vdots\&lt;br /&gt;
b_N \&lt;br /&gt;
\end{pmatrix}
$$&lt;/p&gt;

&lt;p&gt;于是原来带正则项的优化问题就可以按照数据分解到多个子系统上去分别优化，然后汇集起来，形成一个global
consensus问题。&lt;/p&gt;

&lt;p&gt;$$
\begin{array}{lr}
\min &amp;amp; \sum^N_{i=1}l_i(A_ix_i - b_i) + r(z) \&lt;br /&gt;
s.t. &amp;amp; x_i - z = 0, i = 1, \ldots, N \quad x_i, z \in \mathbf{R}^n \&lt;br /&gt;
\end{array}
$$&lt;/p&gt;

&lt;p&gt;结合受约束的凸优化问题时所给出来的具体的ADMM算法解的形式，下面直接给出这些问题的ADMM迭代算法公式&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）Lasso&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;$$
\begin{split}
x_i^{k + 1} &amp;amp; = (A_i^TA_i + \rho I)^{-1}(A_i^Tb_i + \rho (z^k - u_i^k)) \&lt;br /&gt;
z^{k + 1} &amp;amp; = S_{1/\rho N}(\bar{x}^{k + 1} - b + \bar{u}^k) \&lt;br /&gt;
u_i^{k + 1} &amp;amp; = u_i^k + x_i^{k+1} - z^{k + 1} \&lt;br /&gt;
\end{split}
$$&lt;/p&gt;

&lt;p&gt;如果切割的数据量小于维数&lt;em&gt;m&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt; &amp;lt; *n*，那么求解时分解小的矩阵&lt;em&gt;A&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;&lt;em&gt;A&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;&lt;sup&gt;&lt;em&gt;T&lt;/em&gt;&lt;/sup&gt; + *ρ**I*即可；其他求逆采用矩阵加速技巧即可。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）Sparse Logistic Regression&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;$$
\begin{split}
x_i^{k + 1} &amp;amp; =  \arg\min_{x_i}(l_i(A_ix_i - b_i) + (\rho/2)\|x_i - z^k + u_i^k\|^2_2\&lt;br /&gt;
z^{k + 1} &amp;amp; = S_{1/\rho N}(\bar{x}^{k + 1} - \bar{b} + \bar{u}^k) \&lt;br /&gt;
u_i^{k + 1} &amp;amp; = u_i^k + x_i^{k+1} - z^{k + 1} \&lt;br /&gt;
\end{split}
$$&lt;/p&gt;

&lt;p&gt;在&lt;em&gt;x&lt;/em&gt;-update步是需要用一些有效的算法来解决ℓ&lt;sub&gt;2&lt;/sub&gt;正则的logistic回归，比如L-BFGS，其他的优化算法应该问题不大吧。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）SVM&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;注意分类问题和回归问题的损失函数不同，一般都是用&lt;em&gt;l&lt;/em&gt;(sign(&lt;em&gt;t&lt;/em&gt;)&lt;em&gt;y&lt;/em&gt;)形式来寻求最优的分类权重使得分类正确。SVM使用Hinge
Loss：ℓ(&lt;em&gt;y&lt;/em&gt;)=max(0, 1 − *t* ⋅ &lt;em&gt;y&lt;/em&gt;)，即将预测类别与实际分类符号相反的损失给凸显出来。分布式的ADMM形式&lt;/p&gt;

&lt;p&gt;$$
\begin{split}
x_i^{k + 1} &amp;amp; =  \arg\min_{x_i}(\mathbf{1}^T(A_ix_i + 1)_{+} + (\rho/2)\|x_i - z^k + u_i^k\|^2_2\&lt;br /&gt;
z^{k + 1} &amp;amp; = \frac{\rho}{(1/\lambda) + N\rho}(\bar{x}^{k+1} + \bar{u}^k) \&lt;br /&gt;
u_i^{k + 1} &amp;amp; = u_i^k + x_i^{k+1} - z^{k + 1} \&lt;br /&gt;
\end{split}
$$&lt;/p&gt;

&lt;h3 id=&#34;4-3-一般形式的一致性优化问题-切割参数到各子系统-但各子系统目标函数参数维度不同-可能部分重合&#34;&gt;4.3 一般形式的一致性优化问题（切割参数到各子系统，但各子系统目标函数参数维度不同，可能部分重合）&lt;/h3&gt;

&lt;p&gt;上述全局一致性优化问题，我们可以看到，所做的处理不过是对数据分块，然后并行化处理。但是更一般的优化问题是，参数空间也是分块的，即每个子目标函数&lt;em&gt;f&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;(&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;)的参数维度不同&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;, ∈&lt;strong&gt;R&lt;/strong&gt;&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;&lt;/sup&gt;，我们称之为局部变量。而局部变量所对应的的也将不再是全局变量*z*，而是全局变量中的一部分&lt;em&gt;z&lt;/em&gt;&lt;sub&gt;&lt;em&gt;g&lt;/em&gt;&lt;/sub&gt;，并且不是像之前的顺序对应，而可能是随便对应到*z*的某个位置。可令*g* = 𝒢(&lt;em&gt;i&lt;/em&gt;, ⋅)，即将&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;映射到*z*的某部位&lt;/p&gt;

&lt;p&gt;$$(x_i)_j = z_{\mathcal{G}(i, j)} = \hat{z}_i$$&lt;/p&gt;

&lt;p&gt;如果对所有*i*有𝒢(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt;)=*j*，那么&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;与*z*就是顺序映射，也就是全局一致性优化问题，否则就不是。结合下图就比较好理解&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://1xji9q.bn1302.livefilestore.com/y2pcd30upmFtOnC91A1u4CJcxhIVfTuXrreyXRitG-WDxP0LroMiGrrhsnJ_He5ZfwuaFgVJYD-z6kjMfN0-NivkgIh4VspDA9v71PRfPQ0NTU/consensus.png&#34; alt=&#34;consensus&#34; /&gt;&lt;/p&gt;

&lt;p&gt;虽然如果用其他方法来做感觉会复杂，但是纳入到上述ADMM框架，其实只不过是全局一致性优化问题的一个局部化变形，不过此时不是对数据进行分块，是对参数空间进行分块&lt;/p&gt;

&lt;p&gt;$$
\begin{array}{lc}
\min &amp;amp; \sum^N_{i = 1}f_i(x_i) + g(z), x_i \in \mathbf{R}^{n_i}\&lt;br /&gt;
s.t. &amp;amp; x_i - \hat{z}_i = 0, i = 1, \ldots N \&lt;br /&gt;
\end{array}
\Longrightarrow
\begin{split}
x_i^{k+1} &amp;amp; = \arg\min_x (f_i(x_i) + (y^k_i)^Tx_i (\rho/2)\|x_i - \hat{z}_i^k\|^2_2)) \&lt;br /&gt;
z^{k+1} &amp;amp; = \arg\min_z (\sum^N_{i=1}(-(y^k_i)^T\hat{z}_i + (\rho/2)\|x^{k+1}_i - \hat{z}_i\|_2^2))) \&lt;br /&gt;
y_i^{k+1} &amp;amp; = y_i^k + \rho(x_i^{k+1} - \hat{z}_i^{k+1}) \&lt;br /&gt;
\end{split}
$$&lt;/p&gt;

&lt;p&gt;后续想做平均化处理，即中间会发生重合的参数&lt;em&gt;z&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;取值一样的，那么&lt;em&gt;z&lt;/em&gt;-update将只能找他对应的那些*x*进行平均化，也就是变成局部了，因为不是所有值都是要全局保持一致的。比如上面那个图中的&lt;em&gt;z&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;, &lt;em&gt;z&lt;/em&gt;&lt;sub&gt;2&lt;/sub&gt;, &lt;em&gt;z&lt;/em&gt;&lt;sub&gt;3&lt;/sub&gt;, &lt;em&gt;z&lt;/em&gt;&lt;sub&gt;4&lt;/sub&gt;都分别只要求在部分&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;发生了共享需要保持一样，而不是像之前全局要求每个&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;对应的都是*z*。即&lt;/p&gt;

&lt;p&gt;$$
z^{k+1}_g = \frac{\sum_{\mathcal{G}(i,j) = g}((x^{k+1}_i)_j + (1/\rho)(y^k_i)_j)}{\sum_{\mathcal{G}(x, y) = g}1}
$$&lt;/p&gt;

&lt;p&gt;该式子表示就是*z*的第*g*个变量的平均值来源于所有映射到该变量的*x*与*y*的平均值。与之前的global类似，此时对于*y*的取均值会为0，因此&lt;em&gt;z&lt;/em&gt;-update就变成了更简单的形式&lt;/p&gt;

&lt;p&gt;$$
z^{k+1}_g = \frac{1}{k_g}\sum_{\mathcal{G}(i,j)=g} (x^{k+1}_i)
$$&lt;/p&gt;

&lt;p&gt;同全局一致性优化问题一样，我们可以加上正则项，然后也可以变成带正则项的一般形式的一致性优化问题。此处不赘述，与全局基本类似。&lt;/p&gt;

&lt;h2 id=&#34;sharing&#34;&gt;Sharing&lt;/h2&gt;

&lt;h3 id=&#34;4-4-共享问题-sharing-横向切割数据-也可纵向切变量&#34;&gt;4.4 共享问题（sharing）（横向切割数据，也可纵向切变量）&lt;/h3&gt;

&lt;p&gt;与之前的全局变量一致性优化问题类似，共享问题也是一个非常一般而且常见的问题。他的形式如下：&lt;/p&gt;

&lt;p&gt;$$
\min \,\, \sum^N_{i=1}f_i(x_i) + g(\sum^N_{i=1}x_i)
$$&lt;/p&gt;

&lt;p&gt;这里的第一部分局部损失&lt;em&gt;f&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;(&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;)与全局一致性优化是一样的，即所有的&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt; ∈ &lt;strong&gt;R&lt;/strong&gt;&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt;, *i* = 1, …, *N*同维度，而对于一个共享的目标函数*g*则是新加入的。在实际中，我们常常需要优化每个子数据集上的损失函数，同时还要加上全局数据所带来的损失；或者需要优化每个子系统的部分变量，同时还要优化整个变量。共享问题是一个非常重要而灵活的问题，它也可以纳入到ADMM框架中，形式如下：&lt;/p&gt;

&lt;p&gt;$$
\begin{array}{lc}
\min &amp;amp; \sum^N_{i=1}f_i(x_i) + g(\sum^N_{i=1}z_i) \&lt;br /&gt;
s.t. &amp;amp; x_i - z_i = 0, z_i \in \mathbf{R}^n, i = 1, \ldots, N, \&lt;br /&gt;
\end{array}
\Longrightarrow
\begin{split}
x_i^{k+1} &amp;amp; = \arg\min_{x_i} (f_i(x_i) + (\rho/2)\|x_i - z_i^k + u_i^k\|^2_2)) \&lt;br /&gt;
z^{k+1} &amp;amp; = \arg\min_z (g(\sum^N_{i = 1}z_i) + \rho/2\sum^N_{i = 1}\|z_i - x^{k+1}_i - u^k_i\|^2_2) \&lt;br /&gt;
u_i^{k+1} &amp;amp; = u_i^k + x_i^{k+1} - z_i^{k+1} \&lt;br /&gt;
\end{split}
$$&lt;/p&gt;

&lt;p&gt;上述形式当然还不够简洁，需要进一步化简。因为&lt;em&gt;x&lt;/em&gt;-update可以不用担心，分机并行处理优化求解即可，而对于&lt;em&gt;z&lt;/em&gt;-update这里面需要对*N**n*个变量求解，想加快速度，就减少变量个数。于是想办法通过和之前那种平均方式一样来简化形式解。&lt;/p&gt;

&lt;p&gt;对于&lt;em&gt;z&lt;/em&gt;-update步，令&lt;em&gt;a&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt; = &lt;em&gt;u&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;&lt;sup&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sup&gt; + &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;&lt;sup&gt;*k* + 1&lt;/sup&gt;，于是&lt;em&gt;z&lt;/em&gt;-update步优化问题转化为&lt;/p&gt;

&lt;p&gt;$$
\begin{array}{lc}
\min &amp;amp; g(N\bar{z}) + (\rho/2)\sum^N_{i=1}\|z_i - a_i\|^2_2 \&lt;br /&gt;
s.t. &amp;amp; \bar{z} = \frac{1}{N}\sum^N_{i=1}z_i \&lt;br /&gt;
\end{array}
$$&lt;/p&gt;

&lt;p&gt;当$\bar{z}$固定时，那么后面的最优解（类似回归）为$z_i = a_i + \bar{z} - \bar{a}$，带入上式后于是后续优化就开始整体更新（均值化）&lt;/p&gt;

&lt;p&gt;$$
\begin{split}
x_i^{k+1} &amp;amp; = \arg\min_{x_i} (f_i(x_i) + (\rho/2)\|x_i - x_i^k + \bar{x}^k - \bar{z}^k + u^k\|^2_2)) \&lt;br /&gt;
z^{k+1} &amp;amp; = \arg\min_z (g(N\bar{z}) + N\rho/2\|\bar{z} - \bar{x}^{k+1} - u^k\|^2_2) \&lt;br /&gt;
u^{k+1} &amp;amp; = u_i^k + \bar{x}^{k+1} - \bar{z}^{k+1} \&lt;br /&gt;
\end{split}
$$&lt;/p&gt;

&lt;p&gt;另外，有证明如果强对偶性存在，那么global
consensus问题与sharing问题是可以相互转化的，可以同时达到最优，两者存在着很紧密的对偶关系。&lt;/p&gt;

&lt;p&gt;本节开头提过，sharing问题用来切分数据做并行化，也可以切分参数空间做并行化。这对于高维、超高维问题是非常有好处的。因为高维统计中，大样本是一方面问题，而高维度才是重中之重，如果能切分特征到低纬度中去求解，然后在合并起来，那么这将是一个很美妙的事情。上面利用regularized
global
consensus问题解决了切分大样本数据的并行化问题，下面利用sharing思想解决常见的高维数据并行化问题&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;切割变量（特征）空间，并行化处理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;同样假设面对还是一个观测阵*A* ∈ &lt;strong&gt;R&lt;/strong&gt;&lt;sup&gt;*m* × &lt;em&gt;n&lt;/em&gt;&lt;/sup&gt;和响应观测*b* ∈ &lt;strong&gt;R&lt;/strong&gt;&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt;，此时有*n* &amp;gt; &amp;gt;*m*，那么要么就降维处理，要么就切分维度去处理，或者对于超高维矩阵，切分维度后再降维。此时*A*矩阵就不是像之前横着切分，而是竖着切分，这样对应着参数空间的切分：&lt;/p&gt;

&lt;p&gt;$$
A = [A_1, \ldots, A_N], A_i \in \mathbf{R}^{m \times n_i}, x = (x_1, \ldots, x_N), x\in \mathbf{R}^{n_i}, \rightarrow Ax = \sum^N_{i = 1}A_ix_i
$$&lt;/p&gt;

&lt;p&gt;于是正则项也可以切分为$r(x) = \sum^N_{i = 1}r_i(x_i)$。那么最初的min  &lt;em&gt;l&lt;/em&gt;(*A**x* − &lt;em&gt;b&lt;/em&gt;)+&lt;em&gt;r&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)形式就变成了&lt;/p&gt;

&lt;p&gt;$$
\min \,\, l(\sum^N_{i = 1}A_ix_i - b) + \sum^N_{i = 1}r_i(x_i)
$$&lt;/p&gt;

&lt;p&gt;这个与sharing问题非常接近了，做点变化那就是sharing问题了&lt;/p&gt;

&lt;p&gt;$$
\begin{array}{lc}
\min &amp;amp; l(\sum^N_{i=1}z_i - b) + \sum^N_{i=1}r_i(x_i) \&lt;br /&gt;
s.t. &amp;amp; A_ix_i - z_i = 0, i = 1,\ldots, N \&lt;br /&gt;
\end{array}
\Longrightarrow
\begin{split}
x_i^{k+1} &amp;amp; = \arg\min_{x_i} (r_i(x_i) + (\rho/2)\|A_ix_i - A_ix_i^k + \overline{Ax}^k - \bar{z}^k + u^k\|^2_2)) \&lt;br /&gt;
z^{k+1} &amp;amp; = \arg\min_z (l(N\bar{z} - b) + N\rho/2\|\bar{z} - \overline{Ax}^{k+1} - u^k\|^2_2) \&lt;br /&gt;
u^{k+1} &amp;amp; = u_i^k + \overline{Ax}^{k+1} - \bar{z}^{k+1} \&lt;br /&gt;
\end{split}
$$&lt;/p&gt;

&lt;p&gt;与之前的global
consensus问题相比，ADMM框架&lt;em&gt;x&lt;/em&gt;-update与&lt;em&gt;z&lt;/em&gt;-update似乎是反过来了。于是将此形式直接套到Lasso等高维问题即有很具体的形式解了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）Lasso&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;$$
\begin{split}
x_i^{k+1} &amp;amp; = \arg\min_{x_i} (\lambda\|x_i\|_1+ (\rho/2)\|A_ix_i - A_ix_i^k + \overline{Ax}^k - \bar{z}^k + u^k\|^2_2)) \&lt;br /&gt;
\bar{z}^{k+1} &amp;amp; = \frac{1}{N + \rho}(b + \rho \overline{Ax}^{k+1} + \rho u^k) \&lt;br /&gt;
u^{k+1} &amp;amp; = u^k + \overline{Ax}^{k+1} - \bar{z}^{k+1} \&lt;br /&gt;
\end{split}
$$&lt;/p&gt;

&lt;p&gt;当$\|A^T_i(A_ix^k_i + \bar{z}^k - \overline{Ax}^k - u^k)\|_2 \leq \lambda/\rho$时&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;&lt;sup&gt;*k* + 1&lt;/sup&gt; = 0（第*i*块特征不需要用），这样加快了&lt;em&gt;x&lt;/em&gt;-update速度,不过这个对串行更有效，对并行起来也没有多大用..&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）Group Lasso&lt;/strong&gt;
与lasso基本一样，只是在&lt;em&gt;x&lt;/em&gt;-update上有一个正则项的不同，有ℓ&lt;sub&gt;1&lt;/sub&gt;-norm变成了ℓ&lt;sub&gt;2&lt;/sub&gt;-norm&lt;/p&gt;

&lt;p&gt;$$
x_i^{k+1} = \arg\min_{x_i} (\lambda\|x_i\|_2+ (\rho/2)\|A_ix_i - A_ix_i^k + \overline{Ax}^k - \bar{z}^k + u^k\|^2_2)
$$&lt;/p&gt;

&lt;p&gt;该问题其实就是按组最小化(&lt;em&gt;ρ&lt;/em&gt;/2)∥&lt;em&gt;A&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt; − *v*∥&lt;sub&gt;2&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt; + *λ*∥&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;∥&lt;sub&gt;2&lt;/sub&gt;，解为&lt;/p&gt;

&lt;p&gt;$$
\begin{array}{cc}
\text{if}\,\, \|A_i^Tv\|_2 \leq \lambda/\rho, &amp;amp; \text{then}\,\, x_i = 0 \&lt;br /&gt;
\text{otherwise} &amp;amp; x_i = (A^T_iA_i + v I)^{-1}A^T_iv \&lt;br /&gt;
\end{array}
$$&lt;/p&gt;

&lt;p&gt;涉及矩阵长短计算时，再看矩阵小技巧。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）Sparse Logstic Regression&lt;/strong&gt;
也与lasso区别不大，只是&lt;em&gt;z&lt;/em&gt;-update的损失函数不同，其余相同于是&lt;/p&gt;

&lt;p&gt;$$
\bar{z}^{k+1}  = \arg\min_{\bar{z}} (l(N\bar{z})+ (\rho/2)\|\bar{z} - \overline{Ax}^{k+1} - u^k\|^2_2)
$$&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（4）SVM&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SVM与之前的global consensus时候优化顺序反了过来，与logistic
rgression只是在&lt;em&gt;z&lt;/em&gt;-update步不同（损失函数不同）：&lt;/p&gt;

&lt;p&gt;$$
\begin{split}
x_i^{k+1} &amp;amp; = \arg\min_{x_i} (\lambda\|x_i\|_2^2+ (\rho/2)\|A_ix_i - A_ix_i^k + \overline{Ax}^k - \bar{z}^k + u^k\|^2_2)) \&lt;br /&gt;
\bar{z}^{k+1} &amp;amp; = \arg\min_{\bar{z}}(\mathbf{1}^T(N\bar{z}+\mathbf{1})_{+} + (\rho/2)\|\bar{z} - \overline{Ax}^{k+1} - u^{k+1}\|) \&lt;br /&gt;
u^{k+1} &amp;amp; = u^k + \overline{Ax}^{k+1} - \bar{z}^{k+1} \&lt;br /&gt;
\end{split}
$$&lt;/p&gt;

&lt;p&gt;&lt;em&gt;z&lt;/em&gt;-update解析解可以写成软阈值算子&lt;/p&gt;

&lt;p&gt;$$
(\bar{z}^{k+1})_i = \left\{
\begin{array}{ll}
v_i - N/\rho, &amp;amp; v_i &amp;gt; -1/N + N/\rho \&lt;br /&gt;
-1/N, &amp;amp; v_i \in [-1/N, -1/N + N/\rho] \&lt;br /&gt;
v_i, &amp;amp; v_i &amp;lt; -1/N \&lt;br /&gt;
\end{array}
\right.
v_i = (\overline{Ax}^{k+1} + \bar{u}^k)_i
$$&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（5）Generalized Additive Models&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;广义可加模型是一个很适合sharing框架的问题。它本身就是对各个各个特征做了变化后（非参方法），重新表示观测的方式&lt;/p&gt;

&lt;p&gt;$$
b \approx \sum^n_{j = 1}f_j(x_j)
$$&lt;/p&gt;

&lt;p&gt;当&lt;em&gt;f&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;是线性变化时，则退化成普通线性回归。此时我们目标优化的问题是&lt;/p&gt;

&lt;p&gt;$$
\min \,\, \sum^m_{i = 1}l_i(\sum^n_{j = 1}f_j(x_{ij}) - b_i) + \sum^n_{j = 1}r_j(f_j)
$$&lt;/p&gt;

&lt;p&gt;其中有*m*个观测，*n*维特征（变量）。&lt;em&gt;r&lt;/em&gt;&lt;sub&gt;&lt;em&gt;j&lt;/em&gt;&lt;/sub&gt;此时是对一个functional的正则，此时这个问题看起来似乎既可以对数据切分，也可以对特征切分，不过此时仍用sharing问题来做，相当于对特征切分为一个特征为一个子系统，于是有&lt;/p&gt;

&lt;p&gt;$$ \begin{split} f_j^{k+1} &amp;amp; = *{f_i &lt;em&gt;j} (r_j(f_j)+
(/2)^m&lt;/em&gt;{i=1}(f_j(x*{ij}) - f^k_j(x_{ij}) + {z}^k_i + {f}^k_i) +
u&lt;sup&gt;k_i\\ {z}&lt;/sup&gt;{k+1} &amp;amp; = &lt;em&gt;{{z}}(^m&lt;/em&gt;{i=1}l_i(N{z} - b_i) +
/2^n_{j=1}|{z} - {f}^{k+1} - u^k| ,, ,{f}^k =
&lt;sup&gt;n_{j=1}f&lt;/sup&gt;k_j(x_{ij})\ u^{k+1} &amp;amp; = u^k + {f}^{k+1} -
{z}^{k+1} \ \end{split}&lt;/p&gt;

&lt;p&gt;$$&lt;/p&gt;

&lt;p&gt;&lt;em&gt;f&lt;/em&gt;&lt;sub&gt;&lt;em&gt;j&lt;/em&gt;&lt;/sub&gt;是一个ℓ&lt;sub&gt;2&lt;/sub&gt;正则的损失，有直接求解的算法求解，*z*可以一块一块的求解？&lt;/p&gt;

&lt;p&gt;最后再说一个经济学中很重要的sharing问题的特例，即交换问题（exchange
problem）：&lt;/p&gt;

&lt;p&gt;$$
\begin{array}{lc}
\min &amp;amp; \sum^N_{i = 1}f_i(x_i) \&lt;br /&gt;
s.t. &amp;amp; \sum^N_{i = 1}x_i = 0, x_i \in \mathbf{R}^n, i = 1, \ldots N \&lt;br /&gt;
\end{array}
$$&lt;/p&gt;

&lt;p&gt;此时共享目标函数*g* = 0。&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;可以表示不同物品在*N*个系统上的交换数量，(&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;)&lt;sub&gt;&lt;em&gt;j&lt;/em&gt;&lt;/sub&gt;可以表示物品*j*从子系统*i*上收到的交换数目，约束条件就可以看做在这些系统中物品交换是保持均衡稳定的。于是转化为sharing问题，就有很简单的ADMM解法（或者当做之前讲过的受约束的凸优化问题来解，做投影）：&lt;/p&gt;

&lt;p&gt;$$
\begin{split}
x_i^{k+1} &amp;amp; = \arg\min_{x_i} (f_i(x_i) + (\rho/2)\|x_i - x_i^k + \bar{x}^k + u^k\|^2_2)) \&lt;br /&gt;
u^{k+1} &amp;amp; = u_i^k + \bar{x}^{k+1} \&lt;br /&gt;
\end{split}
$$&lt;/p&gt;

&lt;h3 id=&#34;4-4-应用小总结&#34;&gt;4.4 应用小总结&lt;/h3&gt;

&lt;p&gt;感觉上通过consensus problem和general consensus
problem，我们可以看到并行和分布式部署优化方案的可行性。我们可以切分数据以及相应的目标函数，也可以切分变量到各个子系统上去，分别作优化，甚至我们可以大胆想象对不同类型数据块用不同的优化算法，结合consensus问题和ADMM算法，达到同一个global
variable的优化目的；或者对不同变量在不同类型数据块上优化，即使有重叠，也可以结合general
consensus思想和ADMM算法来解决这个问题。当然前提是能够定义好需要估计的参数和优化的目标函数！大规模部署的前景还是很不错的。下面具体分布式统计模型的构建便是ADMM算法非常好的应用。切分数据、切分变量（不过每个子系统的目标函数基本都是一样的，其实应该可以不同）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Nonconvex问题
&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;5-1-变量选择-regressor-selection&#34;&gt;5.1 变量选择（Regressor Selection）&lt;/h3&gt;

&lt;h3 id=&#34;5-2-因子模型-factor-model-fitting&#34;&gt;5.2 因子模型（Factor Model Fitting）&lt;/h3&gt;

&lt;h3 id=&#34;5-3-双凸优化-bi-convex-problem&#34;&gt;5.3 双凸优化（Bi-convex Problem）&lt;/h3&gt;

&lt;p&gt;非负矩阵分解（Nonnegative Matrix Factorization）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;具体实施与实际计算结果
&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这块真的很实际，需要明白MPI的机理和Mapreduce、Graphlab等通信运作的机理，这样才好部署ADMM算法，因为中间有很多迭代，需要做好子节点间参数与整体参数的通信，保持迭代时能同步更新参数。看实际运作，MPI和GraphLab可能更适合这种框架，Hadoop也是可以的，不过毕竟不是为迭代算法所生，要做好需要进行一些优化。Boyd提到Hadoop其中的Hbase更适合这种框架，因为Hbase是一种大表格，带有时间戳，适合记录迭代的记录，这样就不容易导致分布计算时候搞不清是哪一步的迭代结果了，导致通信调整比较复杂。不过在MapReduce框架下实施ADMM算法是没有什么问题的，只要熟稔Hadoop的一些细节部分，基本没有太大问题。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;总结
&amp;mdash;&amp;mdash;-&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一个好的一般性算法，我个人觉得是易实施，并可大规模应用许多问题。可以让统计学家卡在搞算法的瓶颈中解放出来，使得他们能快速用模拟，验证自己构建可能较为复杂的模型。只有当看到一个令人感到欣慰的结果时，那些模型的统计性质的证明才可能是有意义的，如果事先连希望都看不到，那证明起来都可能底气不足，让人难以信服，更难以大规模应用统计学家所构建的模型。现在是一个高维数据、海量数据的年代，算法的重要性更会凸显出来，一个好的模型如果没有一个有效的算法支撑，那么他将可能什么都不是，Lasso头几年所遭遇的冷遇也充分证明了这一点，再比如在没有计算机年代，Pearson的矩估计应用反而远多于Fisher的MLE估计方法也是一个道理。好的一般性的解决方案，我想这不管是优化理论，还是统计等其他应用学科，虽然知道没有最牛最终极的方法，但是能涌现一些大范围适用的方法，那就是再好不过了。一招鲜吃遍天，人还都是喜欢简单、安逸爱偷懒的嘛..&lt;/p&gt;

        
      </description>
    </item>
    
    <item>
      <title>PKU暑期高维统计学习心得(II)</title>
      <link>/2013/08/10/pku-summer-course2/</link>
      <pubDate>Sat, 10 Aug 2013 00:00:00 +0000</pubDate>
      
      <guid>/2013/08/10/pku-summer-course2/</guid>
      <description>
        

&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;

&lt;p&gt;距上一篇时间颇长，不过继续Jiashun老师的讲课心得。上一篇谈到稀疏、弱信号的一种处理框架——Higher
Criticism，在分类、聚类等领域可以有比较好的应用。具体如何应用，此处不详谈，大家可以看看他第二节课的PPT以及该篇论文。在第二节课结束时，他提了一个结论：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Surprisingly, penalization methods (e.g., the L0-penalization method)
are not optimal for rare/weak signals, even in very simple settings
and even with the tuning parameters ideally set。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;也就是说在稀疏、弱信号下，由L0衍生出来的方法并不是最优的，比较容易出问题。虽然我依稀记得某些论文模拟显示信噪比过低时候不少penalty方法结果并不太好，不过Jiashun老师的这个结论还是让我比较吃惊，毕竟被很正经的提出来了，而且他还有相对的解决方案！着实让我很感兴趣。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h3 id=&#34;donoho的不确定原则-uncertainty-principle-与信号恢复&#34;&gt;Donoho的不确定原则（Uncertainty Principle）与信号恢复&lt;/h3&gt;

&lt;p&gt;Jiashun老师说，关于信号恢复最早应该可以追溯到Donoho在1989年的论文&lt;strong&gt;Uncertainty
Principle and Signal
Recovery&lt;/strong&gt;。在这片文章中，Donoho给出了类似于海森堡测不准原理的不确定原则（UP）。海森堡测不准原理通俗来讲即微观粒子某些物理量不可能同时被精确测量准确，一个量越确定，另外一个量的不确定程度就越大。Donoho的不确定原则通俗来讲即，离散时间点
*t* = 0, 1, …, *n* − 1 有观测 &lt;em&gt;Y&lt;/em&gt;&lt;sub&gt;&lt;em&gt;t&lt;/em&gt;&lt;/sub&gt;，做傅里叶变换有&lt;/p&gt;

&lt;p&gt;$$
\hat{Y}_w = \frac{1}{\sqrt{n}}\sum^{n-1}_{t=0}Y_t e^{-2\pi it/n}, \quad w = 0, 1, \ldots, n - 1
$$&lt;/p&gt;

&lt;p&gt;用 &lt;em&gt;T&lt;/em&gt; 和 &lt;em&gt;W&lt;/em&gt; 分别表示 &lt;em&gt;Y&lt;/em&gt;&lt;sub&gt;&lt;em&gt;t&lt;/em&gt;&lt;/sub&gt; 和 $\hat{Y}_w$
中的非零的位置，那么就会得到一个不确定原则，&lt;/p&gt;

&lt;p&gt;$$
\|T\|\cdot\|W\| \geq n, \Longrightarrow \|T\| + \|W\| \geq 2\sqrt{n}
$$&lt;/p&gt;

&lt;p&gt;直观的解释和测不准原理类似，当时域 &lt;em&gt;T&lt;/em&gt;
上的非零点位置很稀疏时，那么关于频域 &lt;em&gt;W&lt;/em&gt;
上的非零点就不会稀疏，他们被一个 $2\sqrt{n}$
的下界给bound住了。也就是说*&lt;strong&gt;T*和*W*不能同时太稀疏&lt;/strong&gt;！虽然这可能是自然界非常普遍的规律，但是我有些疑惑，这个原则对于理解L0有什么意义？&lt;/p&gt;

&lt;p&gt;在信号恢复中有这么个结论，观测 &lt;em&gt;Y&lt;/em&gt;&lt;sub&gt;&lt;em&gt;t&lt;/em&gt;&lt;/sub&gt;
可以完美地被两组基给表示出来跳点基（spikes）和正弦基（sinusoids）&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Y&lt;/em&gt;&lt;sub&gt;&lt;em&gt;t&lt;/em&gt;&lt;/sub&gt; = Spike(&lt;em&gt;t&lt;/em&gt;)+Sinusoid(&lt;em&gt;t&lt;/em&gt;),  *t* = 0, …, *n* − 1&lt;/p&gt;

&lt;p&gt;现假设一个无噪音的模型&lt;/p&gt;

&lt;p&gt;*Y* = *X**β* = ∑&lt;sub&gt;&lt;em&gt;γ&lt;/em&gt;&lt;/sub&gt;&lt;em&gt;β&lt;/em&gt;&lt;sub&gt;&lt;em&gt;γ&lt;/em&gt;&lt;/sub&gt;&lt;em&gt;ϕ&lt;/em&gt;&lt;sub&gt;&lt;em&gt;γ&lt;/em&gt;&lt;/sub&gt;,  *p* = 2&lt;em&gt;n&lt;/em&gt;,  *X* = [&lt;em&gt;Φ&lt;/em&gt;, &lt;em&gt;Ψ&lt;/em&gt;]&lt;/p&gt;

&lt;p&gt;其中 &lt;em&gt;Φ&lt;/em&gt; 和 &lt;em&gt;Ψ&lt;/em&gt; 分别是两组基。
$$[\Phi, \Psi] = [\underline{\phi_1, \ldots, \phi_n}, \underline{\phi_{n+1}, \ldots, \phi_{2n}}]$$
，此处令&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;*T* ⊂ {1, 2, …, &lt;em&gt;n&lt;/em&gt;}, 为“时域”，&lt;/li&gt;
&lt;li&gt;*W* ⊂ {*n* + 1, …, 2&lt;em&gt;n&lt;/em&gt;}, 为“频域”，&lt;/li&gt;
&lt;li&gt;要找到 &lt;em&gt;β&lt;/em&gt; 非零的位置，且具有稀疏性
$\\|T\\| + \\|W\\| \ll n$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目标就是给定 (&lt;em&gt;X&lt;/em&gt;, &lt;em&gt;Y&lt;/em&gt;)，来恢复稀疏的 *β*，此时根据Occam&amp;rsquo;s
Razor的原则，我们相信真实的 &lt;em&gt;β&lt;/em&gt; 应该是最稀疏的。转化为具体形式就是
ℓ&lt;sub&gt;0&lt;/sub&gt; 惩罚，&lt;/p&gt;

&lt;p&gt;(&lt;em&gt;P&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt;): min∥*β*∥&lt;sub&gt;0&lt;/sub&gt;,  such that   *Y* = *X*&lt;em&gt;β&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;虽然基于Occam&amp;rsquo;s Razor原则，那么 ℓ&lt;sub&gt;0&lt;/sub&gt;
的稀疏解是不是唯一的呢？答案是唯一的。之前的UP原则已经暗含了：&lt;strong&gt;对于*Y* = *X&lt;/strong&gt;β*，不可能同时存在多个稀疏解.**&lt;/p&gt;

&lt;p&gt;当然这个唯一性也是有条件的，当&lt;/p&gt;

&lt;p&gt;$$
\|T\| + \|W\| &amp;lt; \sqrt{n}
$$&lt;/p&gt;

&lt;p&gt;时，(&lt;em&gt;P&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt;) 会有唯一解，ℓ&lt;sub&gt;0&lt;/sub&gt;
惩罚是最优的。如何理解这个upper bound的条件呢？&lt;/p&gt;

&lt;p&gt;直观理解，结合不确定原则，时域与频域上非零稀疏个数至少是
$2\sqrt{n}$个，结合UP的那个乘法与加法的不等式，稀疏可以定义为&lt;/p&gt;

&lt;p&gt;$$
\|T\| + \|W\| = 2\sqrt{n} \quad \text{and} \quad \|T| = \|W\| = \sqrt{n}
$$&lt;/p&gt;

&lt;p&gt;如果加上个两者之和最多少于 $\sqrt{n}$
个，也就说明了时域、频域不能同时太稀疏，此时只有一个域上稀疏，那么这种恢复是唯一的。&lt;/p&gt;

&lt;p&gt;如果要证明，也比较简单，形式推论如下：假设同时存在两个稀疏解
&lt;em&gt;β&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt; 和 &lt;em&gt;β&lt;/em&gt;&lt;sub&gt;2&lt;/sub&gt;，那么做差
*σ* = &lt;em&gt;β&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt; − &lt;em&gt;β&lt;/em&gt;&lt;sub&gt;2&lt;/sub&gt; 也是一组稀疏解对于
0 = *X**σ*，同样要满足UP条件，那么就有&lt;/p&gt;

&lt;p&gt;$$
\begin{split}
2\sqrt{n} \leq &amp;amp; \|T(\sigma)\| + \|W(\sigma)\| \&lt;br /&gt;
\leq &amp;amp; \|T(\beta_1)\| + \|T(\beta_2)\| + \|W(\beta_1)\| + \|W(\beta_2)\| \&lt;br /&gt;
&amp;lt; &amp;amp; \sqrt{n} + \sqrt{n} = 2\sqrt{n}
\end{split}
$$&lt;/p&gt;

&lt;p&gt;可以看到与条件矛盾，那么也就是说不会存在两组稀疏解，ℓ&lt;sub&gt;0&lt;/sub&gt;
的解是唯一的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Remark&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;正是由于有这样的结论，所以一直以来我们都相信基于 ℓ&lt;sub&gt;0&lt;/sub&gt;
的稀疏解是最优的，但是我们可能忽略了模型一个关键的假设：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;模型为无噪音，或者是信噪比很高，噪音影响很小&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以回到稀疏、弱信号的场景，我们就会很有理由怀疑基于 ℓ&lt;sub&gt;0&lt;/sub&gt;
惩罚的方法以及相关的衍生的ℓ&lt;sub&gt;1&lt;/sub&gt;惩罚的解是最优的吗？如果不是，如何做才可以处理这种稀疏、弱信号。&lt;/p&gt;

&lt;p&gt;首先我们阐述Occam&amp;rsquo;s
razor对于稀疏弱信号尝试是不太合适的。Jiashun老师给出了一个图形很好的阐述所存在的问题：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://1xkrlw.bn1301.livefilestore.com/y2pfonBhhZDcNwe2c8N8kdiKFMCOvjY7k1McuLh-SRVgEk-oV9KN9HIi0jQ7OABSNI-XN9jUEeDNVOIcCOpwzlYKP9bYs6jcfdgnytqvBp2p2c/occam.png&#34; alt=&#34;occam&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从图中可以看到，如果没有噪音，或者噪音比较小时，恢复较大的真实的信号是很好的，不过当信号很弱，信噪比比较高时候，那么这些真实信号就会被一些噪音包围，而我们也无法分辨出来。用Occam&amp;rsquo;s
razor去挑选最简单的，显然效果会比较差。&lt;/p&gt;

&lt;p&gt;另外一个问题，对于稀疏、弱信号，根据之前的Phase
Diagram的信号恢复区域划分，以及上面这个图形，可以看到精确恢复已经是不可能了，那么用如下定义的*Oracle
property*也就不再合适：&lt;/p&gt;

&lt;p&gt;$$\min_{\beta} \,\, P(\hat{S} \neq S(\beta))$$&lt;/p&gt;

&lt;p&gt;即找出来的非零的系数与真实非零的系数（信号）是同一个的概率非常高，趋近于1。可以看到这种损失函数对于并不强调对于弱信号的发掘，只要大部分强信号找到了就差不多了。一个更为直接的损失函数定义可能是所谓的Hamming距离&lt;/p&gt;

&lt;p&gt;$$\min_{\beta} \,\, \text{Hamm}_p(\hat{\beta}, \beta) = \sum^p_{i = 1}(\text{sgn}(\hat{\beta}_i) \neq \text{sgn}(\beta_i))$$&lt;/p&gt;

&lt;p&gt;由于关注所有系数（系数为0和系数非0）的损失，所有强、弱和无关信号都纳入了优化的目标中，尽量不误估系数为0的和系数非0的，所以要求比Oracle
property更为严苛，希望不放过一丝蛛丝马迹。但是问题也将会变得更为复杂了！&lt;/p&gt;

&lt;p&gt;讨论了这么多，费了很大劲说明之前深以为然的 ℓ&lt;sub&gt;0&lt;/sub&gt;
对于稀疏、弱信号不再是fundamentally
correct了，那接下来有什么办法可以解决呢？推翻旧王朝相对来说还容易点，重新建个新王朝却更难了。Jiashun老师研究了那么久，自然有些办法来处理的。&lt;/p&gt;

&lt;h3 id=&#34;graphlet-screening&#34;&gt;Graphlet screening&lt;/h3&gt;

&lt;p&gt;Jiashun老师开头先讲了个故事，说有次Fan他们来他们那里做分享，很开心的分享他们关于screening、SIS等方面的工作，Jiashun老师自然先不了解Fan做的SIS和ISIS工作，对于screening也构想了自己的方法，但是当他听完Fan老师讲完他的思路后，他大腿一拍，“这不和我的思路一个样嘛！”&lt;/p&gt;

&lt;p&gt;如果诸君了解Fan老师在screenning方面的工作，那么就不会陌生Jiashun老师的思路。与Fan老师的SIS、ISIS思路相同，对于高维问题分两步走，一步screening得到一部分变量，然后对这些变量用些比较精细的方法诸如SCAD惩罚再来挑选，再稍微对第二步迭代调整下，可移除那些假非零系数（假信号）。而Jiashun老师的变量选择的方案也是一个两步方法。&lt;/p&gt;

&lt;p&gt;对于细节此处不详述，我只是谈谈理解。Jiashun老师有两个很重要的想法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;相关性不是噩梦，对于估计可能会降低估计效率（相当于样本减少），但是对于信号检测，却是是一个福音。我举个例子来理解，比如舆情监测，在浩如烟海的网络上有个人喊了句“打到XX”，这信号弱的简直没人知道，但是如果有几个与这个人存在某种关系的人，他们也跟着喊了句“打到XX”，虽然都很弱，但是还是起到了增强信号的作用，相当于几个弱信号汇集一起，让其中一个人发出了怒吼“打到XX”，那么自然这个时候信号检测相对会容易些，而边上的几个弱信号也顺便被检测到。因此要善于利用相关性来增强信号，对于稀疏、弱信号是一个很重要的手段。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;信号稀疏，变量之间的相关性也是稀疏的。将变量间的相关性看做一个图，也就是说信号会分散到很多小子图中，而且这些小子图内部相关性强，而相互之间没什么联系。用形象的话来说，就是信号分散于很多小岛屿上，具体哪些小岛屿有信号还不太清楚，但是我知道信号就分散这些小岛上，小岛上处处散发着信号的微光，而小岛屿之间对另外一个信号的发现没有任何帮助。好比中国大地星星之火隐约可见，却不知他们各自藏身于何处。Jiashun老师对变量间的相关性用一个阈值来控制（screening），以达到图的稀疏（sparse）和seperable（分离）的效果。我个人觉得这个假设有点强，将大图划分为多个独立的子图，这种方法略显有些暴力啊，你想这些星星之火间真的没有联系么？好吧，就当没有什么联系吧，因为我也没啥特别好的想法:(&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因此整体思路就是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;假设变量形成的图 𝒢 是稀疏的，信号可分解为多个独立子图
𝒢&lt;sub&gt;&lt;em&gt;s&lt;/em&gt;&lt;/sub&gt;（最大连通子图）。于是利用相关性对原来的观测进行变化，通过这种方式增强信号后对图𝒢
进行screening，即可获取支撑集，然后分解为多个子 𝒢&lt;sub&gt;&lt;em&gt;s&lt;/em&gt;&lt;/sub&gt;；&lt;/li&gt;
&lt;li&gt;在这些子图上，再利用加惩罚的MLE方法来估计、拟合即可。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;稍微细节点阐述如下&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;首先有个概念称作Graph of Strong
Dependence(GOSD)，即有图𝒢 = (&lt;em&gt;V&lt;/em&gt;, &lt;em&gt;E&lt;/em&gt;)，两个节点有边的条件是$|G(i, j) \geq \frac{1}{\log(p)}|$。因Gram
matrix
*G* = *X*′*X*稀疏可认为图𝒢稀疏。，从GOSD可以引出一个很关键的假设：𝒢&lt;sub&gt;&lt;em&gt;S&lt;/em&gt;&lt;/sub&gt;可以分解为许多不相连接的小块，每个小块都是最大连通子图，即上面的第二点重要的想法。不过图稀疏的，但并不意味着图的结构很简单，稀疏图的小块同样可以很复杂。然后定义*β*的支撑集
*S* = &lt;em&gt;S&lt;/em&gt;(&lt;em&gt;β&lt;/em&gt;)={1 ≤ *i* ≤ &lt;em&gt;p&lt;/em&gt;, &lt;em&gt;β&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt; ≠ 0}
 由支撑对应的节点可以形成子图𝒢&lt;sub&gt;&lt;em&gt;S&lt;/em&gt;&lt;/sub&gt;。&lt;/p&gt;

&lt;p&gt;要估计支撑集的办法与SIS类似，肯定要粗暴点，不能用加惩罚类的最小二乘法（PLS）等来挑选，PLS做下一步的精挑和调整是比较合适的。Fan针对他的模型提出的思路是用边际似然来做对变量重要性排序然后挑选前面重要的变量，这个方法非常常见，没有什么特殊。不过前面讨论过，这些方法都是基于信号比较强的假设提出来的，多余rare/weak的信号是第一步screening就会将信号给踢出大门外，即使下一步再来调整，也基本无望重新找回来。&lt;/p&gt;

&lt;p&gt;在Screening步中，对于rare/weak信号的挑选此时就需要利用上面提到的第一点重要想法，利用相关性来筛选rare/weak信号。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. Univariate Penalized Screening(UPS)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Jiashun老师提出假设简单模型
*Y* = *X**β* + &lt;em&gt;z&lt;/em&gt;,  *z* ∼ &lt;em&gt;N&lt;/em&gt;(0, &lt;em&gt;I&lt;/em&gt;&lt;sub&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sub&gt;)
 UPS方法不是直接对X或Y做screening，而是对变化数据 $\tilde{Y} = X&amp;rsquo;Y$ 做
screening，这其实一种增强信号的处理，以便于挑选rare/weak信号，它与之前Jiashun老师提出
Innovated Higher Criticism 有很强的的关联，先阐述 Innovated HC
方法以便于理解，Innovated HC 也是一种对于 rare/weak
信号挑选比较合适阈值的方法。对于阈值选择问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;直接的想法就是用&lt;a href=&#34;http://joegaotao.github.io/cn/2013/07/PKU-summer-short-course/&#34;&gt;上一次提到的HC方法&lt;/a&gt;，假设各个信号独立无相关性来挑选信号，即
*β* ∼ &lt;em&gt;N&lt;/em&gt;(&lt;em&gt;μ&lt;/em&gt;, &lt;em&gt;I&lt;/em&gt;&lt;sub&gt;&lt;em&gt;p&lt;/em&gt;&lt;/sub&gt;)。但是实际情况多数各种信号噪音间有相关性
*Σ* ≠ &lt;em&gt;I&lt;/em&gt;&lt;sub&gt;&lt;em&gt;p&lt;/em&gt;&lt;/sub&gt;，因此直接用HC似乎不那么美好。&lt;/li&gt;
&lt;li&gt;另外一种想法就是常见的Whitening方法，用 &lt;em&gt;Σ&lt;/em&gt;&lt;sup&gt;−1/2&lt;/sup&gt;&lt;em&gt;β&lt;/em&gt;
线性变化使得变量相关性去掉
&lt;em&gt;Σ&lt;/em&gt;&lt;sup&gt;−1/2&lt;/sup&gt;*β* ∼ &lt;em&gt;N&lt;/em&gt;(&lt;em&gt;Σ&lt;/em&gt;&lt;sup&gt;−1/2&lt;/sup&gt;&lt;em&gt;μ&lt;/em&gt;, &lt;em&gt;I&lt;/em&gt;&lt;sub&gt;&lt;em&gt;p&lt;/em&gt;&lt;/sub&gt;)，然后再用HC方法来挑选。&lt;/li&gt;
&lt;li&gt;还有一种想法就是所谓的Innovated HC，应用HC于如下变化
&lt;em&gt;Σ&lt;/em&gt;&lt;sup&gt;−1&lt;/sup&gt;*β* ∼ &lt;em&gt;N&lt;/em&gt;(&lt;em&gt;Σ&lt;/em&gt;&lt;sup&gt;−1&lt;/sup&gt;&lt;em&gt;μ&lt;/em&gt;, &lt;em&gt;Σ&lt;/em&gt;&lt;sup&gt;−1&lt;/sup&gt;)。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面的三种方法貌似都有一定道理，但是哪种最好呢？对于相关性，我们很多时候认为对估计是不太好的事情，但是对于信号检测，这却是有益的，上面我已经有阐述，所以直接HC会损失不少信息，那么后面两种方法看起来会更好些。当然看是看不出来的，简单计算下便可得出答案。&lt;/p&gt;

&lt;p&gt;假设 &lt;em&gt;μ&lt;/em&gt; 要不是为0，要不为信号 *τ* &amp;gt; 0，&lt;em&gt;Σ&lt;/em&gt; 是一个 2 × 2 分块矩阵
$$
\begin{pmatrix}
1 &amp;amp; h \&lt;br /&gt;
h &amp;amp; 1 \\
\end{pmatrix}
, \quad \|h\| &amp;lt; 1
$$&lt;/p&gt;

&lt;p&gt;稍微一个简单的矩阵计算，三种边际的信噪比（Marginal SNR）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;纯HC：&lt;em&gt;τ&lt;/em&gt;;&lt;/li&gt;
&lt;li&gt;Whitening后HC：$[2/(1+\sqrt{1 - h^2})]\tau$;&lt;/li&gt;
&lt;li&gt;Innovated后HC：[1/(1 − &lt;em&gt;h&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt;)]*τ*。
可以看到变换后，Whitening 和InnovatedSNR 都增加了，但是 Innovated
的增加的更多。用图形来阐述就是下图，左图是原始信号，而右边是经过变换后的信号，原弱信号增强了，当然边上的噪音也会有些增加了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://1xloxw.bn1304.livefilestore.com/y2pR8wojOtsWfBdyn7R_U3IM4yKTWmraFbWvktLKhGFTDUroalL1TzrTSLqrGsfkizxIeZoMSD_6g7u0BAYb3xdm6yDM01dfs6z3oJjTaSmxMU/SNR.png&#34; alt=&#34;innovated&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这种 Innovated HC 与 UPS 方法的联系在于 &lt;em&gt;X&lt;/em&gt;
是随机阵时，有一个完美的随机阵版本（Stein&amp;rsquo;s normal means
model）$X \overset{i.i.d}{\sim} (0, \frac{1}{n}\Omega)$,
而Stein正态均值模型有 *W* ∼ &lt;em&gt;N&lt;/em&gt;(&lt;em&gt;β&lt;/em&gt;, &lt;em&gt;Σ&lt;/em&gt;)，其中
*Σ* = &lt;em&gt;Ω&lt;/em&gt;&lt;sup&gt;−1&lt;/sup&gt;，于是乎 *X*′*Y* = *X*′*X&lt;strong&gt;β* + *X*′*z*，而
*X*′*X&lt;/strong&gt;β* ≈ *Ω&lt;strong&gt;β* 和 *X*′*z* ≈ &lt;em&gt;N&lt;/em&gt;(0, &lt;em&gt;Ω&lt;/em&gt;)，于是
*X*′*Y* ≈ &lt;em&gt;N&lt;/em&gt;(*Ω&lt;/strong&gt;β*, &lt;em&gt;Ω&lt;/em&gt;)，即Innovated
HC。所以UPS方法做Screening会保证一些较好的性质，如Sure
Screening（信号基本都在筛选出来的信号中），Separation After
screening(SAS)（存留的信号满足GOSD，可以拆分多个不相连的子块）。&lt;/p&gt;

&lt;p&gt;虽然这种UPS的方法虽然可以保证较好的性质，不过需要较强的条件，而且还会出现&lt;strong&gt;信号抵消（Signal
cancellation）&lt;/strong&gt;的现象。（该现象在&lt;a href=&#34;http://www.stat.cmu.edu/~roeder/publications/wr2009.pdf&#34;&gt;Wasserman，2009年论文的第五页&lt;/a&gt;举了一个小例子说明这个现象，主要原因就是相关性的介入，虽然真实信号还比较强，但相关性使得估计的信号被抵消而减弱使得screening时候信号被当做噪音给去掉了，导致False
Negative上升了。）这也是一个比较严峻的问题，会导致把许多真信号给删掉了。为了解决这个问题，我们就需要不仅仅只利用UPS，还需要利用之前的Gram
matrix *G* = *X*′&lt;em&gt;X&lt;/em&gt; 蕴含的稀疏图信息，尽量防止Signal
cancellation现象出现。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. Graphlet Screening（GS）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一个直接而暴力的想法，就是扩展UPS，将单变量的screening变成多变量的screening，即多个变量一起满足某个阈值限制时才将这些变量选入，从单变量试到m变量的screening，如果某些变量一直出现，则将其认定为蕴藏了信号，留作下一步的cleaning。这个想法目的就是想消除&lt;strong&gt;Signal
cancellation&lt;/strong&gt;，看起来是*比较有希望*的，不过坏处也显而易见，计算量的急剧增加，将涉及至少$\binom{p}{m}$个子模型的计算，而且也很可能使得选出来的变量更难在下一步中将有用变量与无用变量分离开。因此想法虽然还不错，还是还需要打磨下，于是便有了Jiashun老师Graphlet
Screening的方法，改进的想法如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;只考虑需要考虑的有价值的的子模型，贯穿GOSD的想法到screening和cleaning中，只关注内部有强相关的子图，即仅利用Gram
matrix中的 &lt;em&gt;X&lt;/em&gt;
来大大削减所需要考虑的子模型个数；同时还能解决信号抵消的问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;GOSD降低计算量是因为假设图是 &lt;em&gt;k&lt;/em&gt; -sparse的，这样就从原来的
&lt;em&gt;O&lt;/em&gt;(&lt;em&gt;p&lt;/em&gt;&lt;sup&gt;&lt;em&gt;m&lt;/em&gt;&lt;/sup&gt;) 降到了差不多 &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;k&lt;/em&gt;&lt;sup&gt;&lt;em&gt;m&lt;/em&gt;&lt;/sup&gt;)
的级别。具体的定理证明可详见Jiashun老师的论文和slides，此处再稍微提下GS的算法过程：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;先利用GOSD获取稀疏图，然后在该图上选取子模型，每个子模型的节点数$_0不超过
&lt;em&gt;m&lt;/em&gt;
个，对这些子模型进行screening。由于每个节点于自身互通，于是最初的的子模型都是单节点。&lt;/li&gt;
&lt;li&gt;然后初始化留存节点集
𝒰&lt;sub&gt;&lt;em&gt;p&lt;/em&gt;&lt;/sub&gt;&lt;sup&gt;⋆&lt;/sup&gt;，对每个子模型地节点进行检验，是否要选入该子模型中的部分变量。想法是如果Y在整个该子模型
ℐ&lt;sub&gt;0&lt;/sub&gt; 变量上的投影的平方和，与在该子模型与留存节点集共有变量
$\hat{F}=\mathcal{I}_0 \cap \mathcal{U}^{\star}_p$
上的投影平方和，两者的差值如果大于某个阈值（经验性），则将该子模型的变量与留存变量集的差集变量选入，更新留存变量集（其实是一种适应性卡方检验）。该步骤的直观理解是如果两者的共有变量解释能力所占比重比较小，感觉像噪音，则说明另外一部分变量在该子模型中很可能是信号。&lt;/li&gt;
&lt;li&gt;screening后剩下的变量分解到各个自己的子模型
中ℐ&lt;sub&gt;0&lt;/sub&gt;，对这些子模型分别做类似 ℓ&lt;sub&gt;0&lt;/sub&gt;
变量选择既可挑选各个子模型的有用信号了。下面模型中的系数还有个阈值限制，需要大于&lt;em&gt;v&lt;/em&gt;&lt;sup&gt;*g&lt;strong&gt;s*&lt;/sup&gt;。&lt;em&gt;P&lt;/em&gt;&lt;sup&gt;ℐ&lt;sub&gt;0&lt;/sub&gt;&lt;/sup&gt;
表示在子模型 ℐ&lt;sub&gt;0&lt;/sub&gt; 变量上的投影。
∥&lt;em&gt;P&lt;/em&gt;&lt;sup&gt;ℐ&lt;sub&gt;0&lt;/sub&gt;&lt;/sup&gt;(*Y* − &lt;em&gt;X&lt;/em&gt;&lt;sup&gt;⋆, ℐ&lt;sub&gt;0&lt;/sub&gt;&lt;/sup&gt;)*ξ*∥+(&lt;em&gt;u&lt;/em&gt;&lt;sup&gt;*g&lt;/strong&gt;s*&lt;/sup&gt;)&lt;sup&gt;2&lt;/sup&gt;∥*ξ*∥&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;整体看来，过程还是显得有些繁琐，引入了不少参数，这些阈值参数有些给出了解析式子，有些比如
&lt;em&gt;v&lt;/em&gt;&lt;sup&gt;*g&lt;strong&gt;s*&lt;/sup&gt;
却比较难选择。算法给完后面免不了是不少理论性质的证明，在严苛的Hamming
loss上可以最优，比lasso好，Phase
diagram上表现也很好等等好的理论性质，不过这些我都没怎么细看了，一时看不明白也看不完呀！总之给我的印象就是还不错！不过遗憾在于相比HC框架的简约不用给代码，但是这个模型还是做个R包或者给点代码吧，践行Zou
Hui的&lt;/strong&gt;统计产品**理念看来还是有必要的:)&lt;/p&gt;

&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;总之，Jiashun老师的想法就是想尽可能地挖掘变量间的关系来帮助变量选择。之前Zou
hui的&lt;a href=&#34;http://pages.cs.wisc.edu/~shao/stat992/zou2006.pdf&#34;&gt;Adaptive
lasso&lt;/a&gt;，Bulhman的&lt;a href=&#34;http://arxiv.org/pdf/0808.1013.pdf&#34;&gt;Multi-step变量选择&lt;/a&gt;，Longzhe利用&lt;a href=&#34;http://bioinformatics.oxfordjournals.org/content/24/9/1175.full&#34;&gt;network做laplacian惩罚&lt;/a&gt;，还有相似的Cun-hui老师先学adjacency
matrix，然后&lt;a href=&#34;http://arxiv.org/pdf/1112.3450.pdf&#34;&gt;MCP+laplacian惩罚来做变量选择&lt;/a&gt;，以及今年在北京大学春季统计会议上Jinzhu老师提出的&lt;a href=&#34;http://arxiv.org/pdf/1208.5584.pdf&#34;&gt;preconditioning方法&lt;/a&gt;，用SVD的
&lt;em&gt;U&lt;/em&gt; 矩阵和 &lt;em&gt;D&lt;/em&gt; 矩阵来对 &lt;em&gt;X&lt;/em&gt;
做变换，也都是想对原始的变量进行挖掘，想办法在更弱的条件下来做更准确的变量选择，不过我更倾向于用图（变量关系）来提高变量选择的准确性，Witten和Tibshirani的&lt;a href=&#34;http://www-stat.stanford.edu/~tibs/ftp/WittenTibshirani2008.pdf&#34;&gt;Scout方法&lt;/a&gt;比较切合我的意图，不过现在看到Jiashun老师的思路和想法，不禁还是被深深吸引，在Gram
Matrix上和变量变换上做文章，想法很好很深刻，何况还有之前的HC框架呢！尽管论文比较难读，涉及很多性质证明，我也基本没怎么细看，但是我想如果有可能，还是希望能够在这个基础上再继续做点东西吧，但愿:)&lt;/p&gt;

        
      </description>
    </item>
    
    <item>
      <title>PKU暑期高维统计学习心得(I)</title>
      <link>/2013/07/19/pku-summer-course1/</link>
      <pubDate>Fri, 19 Jul 2013 00:00:00 +0000</pubDate>
      
      <guid>/2013/07/19/pku-summer-course1/</guid>
      <description>
        

&lt;h3 id=&#34;印象&#34;&gt;印象&lt;/h3&gt;

&lt;p&gt;为其两个周的北大关于高维统计的暑期课程即将告一段落，我回来奔跑了两周，身体略感疲惫，现在总算可以休息下，然后停下来消化下讲过的内容。&lt;/p&gt;

&lt;p&gt;这次来讲课的老师学术能力都很强，都是四大paper等身的青年学者。老师们讲课的风格不一，最好玩的当属Tiefeng
Jiang老师，他讲起课来就像说东北二人转，段子一个接一个，东北味的口音让我第一节课毫不犯困。而且深入浅出，随机矩阵这种比较数学的研究领域，也被他讲的比较好理解。不过后面由于有事情，以及之后的内容过于数学化，我就没有再跟下去了。Zhu
Ji老师讲的很细致，不过内容偏简单了，听了两节课后我也没有跟下去。Cun-Hui
Zhang老师做的很理论，深厚的数理分析功底，以及对高维问题理解的深刻让我感觉很敬畏，不敢靠近。对他后面做的scaled
lasso和LPDE的结果很感兴趣，想用来做点检验的试验，不过邮件找老师要代码现在还没有回复，略感伤心，看来只能过几天自己写了。Yang
Feng老师很年轻，在Fan老师那边做了很多非常好的工作，不过由于之前我看了不少Fan老师的东西，对他的讲的思路相对比较熟悉，也就没有太用心听而刷微博、做项目去了，真是一大罪过啊！&lt;/p&gt;

&lt;p&gt;整个课程中对统计所持的观点和态度，我最欣赏的是Hui Zou和Jiashun Jin老师。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;Hui Zou老师在变量选择、图模型做了不少很好的工作，比如现在很常用的elestic
net、adaptive lasso等，都是非常简约而好用的工具。Hui
Zou老师为人谦虚，对自己所做的东西不夸耀、不吹捧，他认为统计的工作更像是“完成一个产品”的工作，做出来的方法最好能做成软件包为人所用，而且还要比较好用，所以他的文章不少都会附上R包。这一点我很喜欢，统计本身就是一个应用的学科，如果做的过于数理，缺少实际的价值，并且算法写的没效率没法用，这些都是没法促成统计在现实生活大规模应用的。我觉得当前统计之所以这么热，也主要是当年统计从英国转入美国后，有了Tukey等人不断地大力推动数据分析的理念，推进一些有效的统计分析方法，才有了现在统计一片大热的局面和现在所谓大数据的时代。&lt;/p&gt;

&lt;p&gt;Zou
Hui老师还提倡多做实验，多种方法多做比较，不要限制于一种方法上。我深以为然。以前我学习统计的感觉就是一定要找一个方法完美的解决这个问题，和做数学问题样，做到一个唯一解。后面我逐渐的体悟到，统计面对的是数据，它本身就是具有随机性的，用多种方法来看这个数据虽然结果会有差异，也许某个方法表现比较好，但是不是说明这个方法在后面遇到了同类型的问题时候，在使用这个方法的效果就一定会好。就拿各种penalty的方法，真实数据你也不知道信噪比如何，回归系数是怎么样，也许模拟结果显示某某方法很好，超越了其他方法，但是面对真实数据，好的方法只是“概率性”地增加了我的信心，我无法确定scad一定比lasso分析的好，何况那些oracle性质只是概率意义上的呢，谁知道不会发生小概率事件并且后面Jiashun老师提到的rare/weak
signal问题更加增加了我对这些方法的恐慌。所以，做完理论后，回归到数据分析，唯一的办法就是多做比较，大胆假设，小心论证，发现共同的证据，这才是做统计和做数据分析的思维。&lt;/p&gt;

&lt;p&gt;整个暑期课程对我思维激发最大的是Jiashun
Jin老师的课程内容。由于课程进度有些快，加上这几天比较忙，我也没有研读老师paper，所以此处只是记录些大概想法，后面有时间会深入探讨。&lt;/p&gt;

&lt;h3 id=&#34;higher-criticism-and-rare-weak-signals&#34;&gt;Higher Criticism and Rare/Weak Signals&lt;/h3&gt;

&lt;p&gt;Jiashun老师讲关于稀疏、弱信号（rare/weak
signals）共三节课，最核心的是Higher Criticism and rare/weak
signals，然后还有就是关于变量选择的新思维。&lt;/p&gt;

&lt;p&gt;关于稀疏、弱信号，Jiashun老师认为在大p小n的情况下，有许多没有用的特征，当真实信号非常稀疏和微弱时，参数空间存在着一块&lt;strong&gt;不可能对参数进行很好推断&lt;/strong&gt;的区域。&lt;/p&gt;

&lt;p&gt;而导致信号过弱的情况，一个直接原因就是样本过少。信号强度以样本量存在一个2次的比例关系（一般CLT的速度）&lt;/p&gt;

&lt;p&gt;(signal strength)^2 ∝ *n* ∝ dollars or manpower&lt;/p&gt;

&lt;p&gt;这是一个很浅显的道理，增加样本（如果样本不是高度相关抽样所得），信号肯定会增强，但是很多情况下，随着样本增加，成本会大大提高，或者是维数又会大大增加，信号仍旧比较弱，那么此时如何去恢复或者估计呢？&lt;/p&gt;

&lt;p&gt;很多情况下，人们都认为他们的数据中信号是很强的，所以可以直接用那些高维的惩罚方法来恢复信号，或者认为强信号与弱信号之间存在巨大的鸿沟，他们可能没法互相转化，又或者认为信号很弱时，我们什么都不用干，因为什么方法都没用。一般来说，大海里捞针，信号本身确实挺弱的，要想寻找到这样的信号，确实是件非常难的事情。但是我们可以提出一个问题：什么样的情况下我们可以通过一些高维的方法找到这样的弱信号，在什么样的情况下我们又无法很好找到弱信号呢？如何量化这种信号可估和不可估的区域呢？&lt;/p&gt;

&lt;p&gt;Jiashun老师从FDR的弱点出发引出了自己的思路。&lt;/p&gt;

&lt;p&gt;对于简单的问题&lt;/p&gt;

&lt;p&gt;$$Y_i = \mu_i + \sigma z_i, \quad z_i \overset{iid}{\sim} N(0, 1), \quad i = 1, 2, \ldots, p$$&lt;/p&gt;

&lt;p&gt;如果只有很少量的信号&lt;em&gt;μ&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;不为0，挑选信号的一个直接的方法就是用Wavelet
hard-thresholding，给出一个阈值&lt;/p&gt;

&lt;p&gt;$$
\hat{\mu}_i^H = \left \{
\begin{array}{lc}
y_i, &amp;amp; |y_i| \geq \sigma \cdot t \&lt;br /&gt;
0, &amp;amp; \text{otherwise}
\end{array}
\right.
$$&lt;/p&gt;

&lt;p&gt;这个时候选择阈值 &lt;em&gt;t&lt;/em&gt;
就是一个艺术化的工作，选大了会导致很多信号选不到，选小了就会导致很多噪音进来。一种选择阈值的方法即通过控制FDR水平（错误发现率），通俗的说，如果能使得选出来的信号中是假信号（噪音）的比例控制在一定水平之下，这样我们也是可以接受的，毕竟真信号还是选出来了，只是附带了一部分噪音罢了。想法是好的，但是实际中，用FDR控制阈值很可能选不到任何信号，因为我们期望FDR能有效果是基于一个信念：信号虽然稀疏，但是还是&lt;strong&gt;强（strong）&lt;/strong&gt;的，所以我们也许还是可以找到个相对好的阈值
&lt;em&gt;t&lt;/em&gt;
来找到强信号。但是现实中如果信号是弱的，信噪比比较高时，用FDR报告出来的信号便很可能是假的，因此控制FDR还是无法到达选较好阈值的目的。按Jiashun老师的话说，FDR其实与阈值选择没有太大关系，两个不太一样的目标。&lt;/p&gt;

&lt;p&gt;于是Jiashun老师从检测稀疏混合分布（Detection of sparse
mixtures）出来来导出他的想法和框架，与FDR有些类似，但是效果却大不相同。&lt;/p&gt;

&lt;p&gt;做如下假设检验：&lt;/p&gt;

&lt;p&gt;$$
\begin{array}{lr}
H_0 : X_1 \overset{iid}{\sim}N(0, 1), &amp;amp; 1 \leq i \leq p \&lt;br /&gt;
H_1^{(p)}: X_i \overset{iid}{\sim}(1 - \epsilon_p)N(0, 1) + \epsilon N(\tau_p, 1), &amp;amp; 1 \leq i \leq p
\end{array}
$$&lt;/p&gt;

&lt;p&gt;原假设即各变量是噪音，备择假设是各变量是一种噪音与信号的混合。其中参数有如下形式&lt;/p&gt;

&lt;p&gt;$$
\begin{array}{lc}
\epsilon_p = p^{-\beta}, &amp;amp; 0.5 &amp;lt; \beta &amp;lt; 1 \&lt;br /&gt;
\tau_p = \sqrt{2r\log p}, &amp;amp; 0 &amp;lt; r &amp;lt; 1
\end{array}
$$&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当 &lt;em&gt;ϵ&lt;/em&gt;&lt;sub&gt;&lt;em&gt;p&lt;/em&gt;&lt;/sub&gt; 很小时，比如 $\epsilon_p \ll 1/\sqrt{p}$
时，意味着只有极少的非零均值，此参数刻画着信号稀疏性（ &lt;em&gt;β&lt;/em&gt;
越大，&lt;em&gt;τ&lt;/em&gt;&lt;sub&gt;&lt;em&gt;p&lt;/em&gt;&lt;/sub&gt; 越小，信号越越稀疏）；&lt;/li&gt;
&lt;li&gt;当 &lt;em&gt;τ&lt;/em&gt;&lt;sub&gt;&lt;em&gt;p&lt;/em&gt;&lt;/sub&gt;
比较小时，信号相对比较弱，此参数刻画着信号的强弱（&lt;em&gt;r&lt;/em&gt;
越大，信号越强）；一般 $\tau_p &amp;lt; \sqrt{2 \log p}$
时，信号就凑合能用了（only moderate significance）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于两个分布的检验（上述参数固定时候），Neyman-Pearson检验最优。那么自然我们就想通过似然比检验来刻画上述参数(&lt;em&gt;β&lt;/em&gt;, &lt;em&gt;r&lt;/em&gt;)不同区间的检验效力了。于是就有了如下非常惊艳的有关信号检测的Phase
Diagram&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://1xlhga.bn1301.livefilestore.com/y2pYbzYr-kSidbDba1eluxy8DunNQ_Y35tLh0_5rAwa-8PlVJ5Gmy9vd1UUa1Syw-V5hcJkn2ESY86DcDzY-7679-JjHlX4xabIvyb8mO7LCCw/hc.png&#34; alt=&#34;hc&#34; /&gt;&lt;/p&gt;

&lt;p&gt;此处划分了四个区域：可精确恢复（exact recovery）；几乎能全恢复（almost
full
recovery）；可检测的（detectable）；不可检测的（undetectable）。这些都是概率的语言，表示的概率强度不同。横坐标
&lt;em&gt;β&lt;/em&gt; 越大表示信号越稀疏，纵坐标 &lt;em&gt;r&lt;/em&gt;
越大表示信号越强。很多理论的结论都是在 *r* &amp;gt; 1
时的结论，也就是信号很强的时候咋算都会又不错的估计效果。右图是将横纵坐标都限制在
(0, 1)
区间中，而这一块也正是我们感兴趣的地方，信号稀疏而且很弱的时候估计效果如何？经过一些与检验相关的计算，这些曲线是可以直接算出来的，可以刻画可检测、不可检测、可估计的区域范围。&lt;/p&gt;

&lt;p&gt;我觉得这是一个非常能激发思维的结论。对于不可检测的区域，过于稀疏和过于弱的信号，尝试努力恢复的性价比是非常低的，几乎不可能；对于可估（estimatable）的区域，用现在常见的penalty方法基本可以做到比较好的恢复，能够分离开信号与噪音；但是对于可检测（detectable）的区域，虽然我们知道那里面有信号，但是几乎不可能将它们与噪音区分开（FDR失效），不过如果是做信号检测、分类、聚类等工作，进行有效的推断还是仍然有可能的。此时进行推断的框架不是FDR，而需要一个对稀疏、弱信号更敏感的框架，它有个响亮的名字——Higher
Criticism。&lt;/p&gt;

&lt;p&gt;Higher Criticism，我直译为为高阶鉴别法，Jiashun老师说始于Tukey
1976年Stat
411课程讲义笔记，大师的思维光芒真是能穿越历史呀。Jiashun老师推导的HC与Tukey的略有不同，更为一般化，式子如下：&lt;/p&gt;

&lt;p&gt;$$
HC^{*}_p = \max_{0 \leq \alpha \leq \alpha_0}\big\{
\sqrt{p}\big[\frac{\text{fraction significant at }\alpha - \alpha}{\sqrt{\alpha(1 - \alpha)}}\big]
\big\}
$$&lt;/p&gt;

&lt;p&gt;其中 &lt;em&gt;α&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt;
可以是1/2或1。一眼就可以看出来，这是一个比例估计的检验——分子是在控制 &lt;em&gt;α&lt;/em&gt;
水平时实际个体显著的比例与真实比例 &lt;em&gt;α&lt;/em&gt; 的差异；分母将 $\sqrt{p}$
拿到分母下就是比例 &lt;em&gt;α&lt;/em&gt; 的方差。那么这么做的含义是什么？&lt;/p&gt;

&lt;p&gt;仔细想下，这蕴含着一个二阶显著检验问题（second-level significance&lt;/p&gt;

&lt;h1 id=&#34;testing-想要知道在哪个水平下-我们检验的显著个体是真实-如果只看在某个水平下是否显著-一阶证据-然后依此证据来寻找显著个体其实并不十分理智-比如做了250次独立的检验-有11个在5-水平下显著-实际期望的平均显著个数是250-0-05&#34;&gt;testing）。想要知道在哪个水平下，我们检验的显著个体是真实，如果只看在某个水平下是否显著（一阶证据），然后依此证据来寻找显著个体其实并不十分理智。比如做了250次独立的检验，有11个在5%水平下显著，实际期望的平均显著个数是250*0.05&lt;/h1&gt;

&lt;p&gt;12.5个，也就是说在原假设为真的情况——假信号（噪音），也会有12.5个会显著。而11个与12.5个有差距很小的，所以我们很有理由怀疑这11个显著的信号不是是真信号，而很可能都是噪音。如果实际显著个数比期望显著个数大很多，那么我们可能更愿意相信在该显著水平
&lt;em&gt;α&lt;/em&gt; 下，真能会发现不少的信号。所以我们的目标就是想要调
*α*，看哪个水平下，这个HC值最大，这时候我们可以认为在这个水平下，我们可以发现信号，是可以检测的。&lt;/p&gt;

&lt;p&gt;Jiashun老师说，HC值对强信号、弱信号检测都非常敏感，而FDR仅对强信号敏感。我粗浅地想可能就是HC值基于p值后又做了一次检验的缘故吧。由于没有去做Jiashun老师留下的作业，所以理解还不深刻。后面还是回头再算算Phase
Diagram中的边界曲线来加深理解。&lt;/p&gt;

&lt;p&gt;Higher Cirticism实施比较简单，过程与FDR过程很类似。步骤如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;对每个特征都算一个z-score，然后根据z-score算个p值，&lt;/li&gt;
&lt;li&gt;对p值排序：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;π&lt;/em&gt;&lt;sub&gt;(1)&lt;/sub&gt; &amp;lt; &lt;em&gt;π&lt;/em&gt;&lt;sub&gt;(2)&lt;/sub&gt; &amp;lt; ⋯ &amp;lt; &lt;em&gt;π&lt;/em&gt;&lt;sub&gt;(&lt;em&gt;p&lt;/em&gt;)&lt;/sub&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;计算第*k*个HC值，也相当于算了一个z-score：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;$$HC_{p, k} = \sqrt{p}\big[\frac{\frac{k}{p}-\pi_{(k)}}{\sqrt{\pi_{(k)}(1 - \pi_{k})}}\big]$$&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;取最大值，计算相应的 *H*&lt;em&gt;C&lt;/em&gt;&lt;sub&gt;&lt;em&gt;p&lt;/em&gt;&lt;/sub&gt;&lt;sup&gt;*&lt;/sup&gt;
值，找到对应的 *k*，前 &lt;em&gt;k&lt;/em&gt; 可以认为是真显著的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;*H&lt;strong&gt;C*&lt;sub&gt;&lt;em&gt;p&lt;/em&gt;&lt;/sub&gt;&lt;sup&gt;*&lt;/sup&gt; = max&lt;sub&gt;1 ≤ *i* ≤ &lt;em&gt;α&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt; ⋅ &lt;em&gt;p&lt;/em&gt;&lt;/sub&gt;{*H&lt;/strong&gt;C*&lt;sub&gt;&lt;em&gt;p&lt;/em&gt;, &lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;}&lt;/p&gt;

&lt;p&gt;对应着下面的图形大约可以可以理解这个过程，横轴是实际比例
&lt;em&gt;k&lt;/em&gt;/*p*，目的就是找到一个阈值，可以帮助我们检测到信号。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://1xisda.bn1302.livefilestore.com/y2p3dEywCYLZ4Hy1Rhs8uoicppH9hvrwVBdCUUOcFudDC67x1_Y-uzdxE-EVvZkhs3IxHnNAmVVFJ42GbdN9vhRIl_7J4uUxIysP9Ctt9AtePI/hc1.png&#34; alt=&#34;hc1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后Jiashun老师给出了他在2004年和他导师Donoho的一篇论文的结果，证明了
*H*&lt;em&gt;C&lt;/em&gt;&lt;sub&gt;&lt;em&gt;p&lt;/em&gt;&lt;/sub&gt;&lt;sup&gt;*&lt;/sup&gt; 有最优的适应性(adaptivity)，证明
$HC^{\ast}_p &amp;gt; \sqrt{4\log\log(p)}$
时，可以获得犯第一类错误与第二类错误之和趋近于0。&lt;/p&gt;

&lt;p&gt;Higher
Criticism在宇宙学、天文学、基因、异常检测中研究比较多，因为那里的信号比较稀疏和弱，常规的方法已经不能满足需求。另外，HC非常适用于高维的screening、signal
detection、classification、clustering等方向，用HC来控制screening中的阈值，比常规的CV、FDR等方法提供了一个新的角度，并且简单有效，无需调参，理论性质也挺好。&lt;/p&gt;

&lt;p&gt;P.s.
一不小心突然发现写太多了，本只是记录下心得，不过写着写着觉得还是要重新捋一捋思路才行。之所以写这么多，很大原因是我对penalty太细节化的讨论感到有些厌倦了，里面谈到的统计思想性的东西并不多，所以Jiashun老师东西对我来说比较新颖，便一下子记录了不少，以留作后续继续研读。&lt;/p&gt;

&lt;p&gt;Jiashun老师后面还回顾了L0方法的本源，然后说明了在在稀疏、弱信号下，基于L0而衍生的一系列penalty方法都存在比较大的问题。这个论证让我感觉耳目一新，留作下篇再续。希望后面能在深入了解下Jiashun老师的工作，能够有更深的理解，能跳出当前的状态，既能看到他的方法好处，也能看到他的方法的弱点所在，因为我相信没有一种方法是万能的，总会有不完美的地方。&lt;/p&gt;

&lt;h3 id=&#34;送别&#34;&gt;送别&lt;/h3&gt;

&lt;p&gt;总之，两个星期的课程悄然结束。最后Yang
Feng老师说希望大家有一个欢乐的暑假时，我才意识到课程真的已经结束。这也意味着陪同我一起上课好朋友兼极客同志——小南，晓矛师弟、赛姐师妹即将离开北京，各自踏上自己的征途。回家写R包的写R包，远赴米国读博的读博，而我，还要坚守在北京，继续着前进的道路。其实感慨良多，因为研一这一年经历了不少心理的改变，尤其是2013年。不过，无论做什么，就全力以赴吧。遥祝晓矛、赛姐米国修炼过程顺利顺心，早日学成归来。祝小南同志潜心修道，将学术理论进行到底，早日成为一名极客+理论家。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://pan.baidu.com/share/link?shareid=2717730273&amp;amp;uk=771858297&#34;&gt;本次暑假课程的PPT（最后一天的还没有）加我下载的相关的论文在此了&lt;/a&gt;，愿喜欢这块内容的诸君好好学习！&lt;/p&gt;

        
      </description>
    </item>
    
    <item>
      <title>高维变量选择问题的一点总结</title>
      <link>/2013/07/05/high-dim-summary/</link>
      <pubDate>Fri, 05 Jul 2013 00:00:00 +0000</pubDate>
      
      <guid>/2013/07/05/high-dim-summary/</guid>
      <description>
        &lt;p&gt;近十年来，不管是统计界还是计算机界，高维数据问题依然是最热的话题。大数据时代带来的不仅仅是海量的数据，更多的是数据的复杂性和维度的多样性。对于一个个体的描述，我们不再仅仅是通过几个体征属性来描述，并试图通过一些方法来对个体做推断。伴随着互联网用户行为数据的收集、个体生理指标的测量，纵向数据、函数型数据、Tensor型数据大量涌现，描述个体的角度变得丰富多彩起来，我们总希望从这些复杂的关系中拨开云雾，发现数据间千丝万缕的关系，进而推断因果、预测未来。我不知道后面几十年这个目标是否可以实现，但是从目前的进展看，似乎还是有希望的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://pic.biodiscover.com/files/u/6v/201303081346539541.jpg&#34; alt=&#34;gene&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在这个背景下，我也赶了潮流，这一年基本都浸淫在高维问题中，也算熟悉了其中的一些理论。不过看多了高维问题也确实让人感到厌倦和烦躁，总感觉外表很酷，头脑干瘪，丧失了不少统计的味道。相反，有时简洁有趣的数据分析反而让人感觉更舒服，毕竟具体、实际的问题相比到处泛滥的理论更吸引人。&lt;/p&gt;

&lt;p&gt;目前我的这些总结还不多，很多东西都记录的是自己感兴趣的部分。其中主要沿着Fan 2001年的关于Concave Penalty的思路以及后续的发展进行了总结。他的文章对Penalty的问题讨论的很细致很深刻，2013年Fan又进一步提出了Folded Concave Penalty的一些性质，发展了一个较为统一的框架，结合2008年Zou提出的LLA算法，Concave Penalty的求解问题也变得快速，不需要Lasso问题的那些限制条件也具有良好的理论性质。不过正如Fan自己所说，如果没有之前对Lasso问题的详细讨论，LLA算法也不会提出来，虽然与LQA只是一个泰勒展开阶数的差别，但是实际效果却大不一样。潮流总在变化，估计Fan也是不甘心他的思路被现在各种五花八门的Penalty给淹没了吧。&lt;/p&gt;

&lt;p&gt;总结文档在&lt;a href=&#34;https://github.com/joegaotao/highDim/blob/master/highDim.pdf&#34;&gt;Github&lt;/a&gt;上，欢迎补充Lasso方面的内容，后续我会添加一些关于高维矩阵方面的心得。&lt;/p&gt;

        
      </description>
    </item>
    
  </channel>
</rss>
